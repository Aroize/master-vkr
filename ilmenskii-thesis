\documentclass[specification,annotation,times]{itmo-student-thesis}

%% Опции пакета:
%% - specification - если есть, генерируется задание, иначе не генерируется
%% - annotation - если есть, генерируется аннотация, иначе не генерируется
%% - times - делает все шрифтом Times New Roman, собирается с помощью xelatex
%% - languages={...} - устанавливает перечень используемых языков. По умолчанию это {english,russian}.
%%                     Последний из языков определяет текст основного документа.

%% Делает запятую в формулах более интеллектуальной, например:
%% $1,5x$ будет читаться как полтора икса, а не один запятая пять иксов.
%% Однако если написать $1, 5x$, то все будет как прежде.
\usepackage{icomma}

%% Один из пакетов, позволяющий делать таблицы на всю ширину текста.
\usepackage{tabularx}

%% Данные пакеты необязательны к использованию в бакалаврских/магистерских
%% Они нужны для иллюстративных целей
%% Начало
\usepackage{tikz}
\usetikzlibrary{arrows}
\usepackage{filecontents}
\begin{filecontents}{master-thesis.bib}
\end{filecontents}
%% Конец

%% Указываем файл с библиографией.
\addbibresource{master-thesis.bib}

\begin{document}

\studygroup{M4200C}
\title{Проектирование и реализация набора модулей c унифицированным интерфейсом для разработки группы мобильных приложений}
\author{Ильменский Илья Андреевич}{Ильменский И.А.}
\supervisor{Пономарёв Вадим Анатольевич}{Пономарёв В.А.}{доцент}{факультет информационных технологий и программирования}
\publishyear{2025}
%% Дата выдачи задания. Можно не указывать, тогда надо будет заполнить от руки.
\startdate{01}{марта}{2025}
%% Срок сдачи студентом работы. Можно не указывать, тогда надо будет заполнить от руки.
\finishdate{31}{мая}{2025}
%% Дата защиты. Можно не указывать, тогда надо будет заполнить от руки.
\defencedate{15}{июня}{2019}

\addconsultant{TODO()}{TODO()}
\addconsultant{TODO()}{TODO()}

\secretary{Штумпф С. А.}

%% Задание
%%% Техническое задание и исходные данные к работе
\technicalspec{TODO()}

%%% Содержание выпускной квалификационной работы (перечень подлежащих разработке вопросов)
\plannedcontents{TODO()}

%%% Исходные материалы и пособия 
\plannedsources{\begin{enumerate}
    Исходные материалы и пособия работой не предусмотрены
\end{enumerate}}

%%% Цель исследования
\researchaim{TODO()}

%%% Задачи, решаемые в ВКР
\researchtargets{\begin{enumerate}
    \item TODO()
\end{enumerate}}

%%% Использование современных пакетов компьютерных программ и технологий
\addadvancedsoftware{TODO()}

%%% Краткая характеристика полученных результатов 
\researchsummary{TODO()}

%%% Гранты, полученные при выполнении работы 
\researchfunding{TODO()}

%% Эта команда генерирует титульный лист и аннотацию.
\maketitle{Магистр}

%% Оглавление
\tableofcontents

%% Макрос для введения. Совместим со старым стилевиком.
\startprefacepage

В данном разделе размещается введение.

%% Начало содержательной части.
\chapter{Постановка задачи}

\section{Актуальность темы}

В настоящее время компании расширяют ассортимент поддерживаемых продуктов и решений, что приводит к ряду организационных и технических вызовов. В частности, отсутствие унифицированного базового функционала между различными продуктами способствует увеличению сроков их разработки (Delivery). Это также приводит к повторному возникновению и решению одних и тех же проблем внутри одной компании, что снижает эффективность разработки.

Описанная проблема не обошла стороной компанию Visify. Отсутствие стандартов к написанию кода, а также отсутствие общей кодовой базы для базовых решений на нескольких проектах привело к значительным объемам дублирования функционала. В конечном итоге, это усложнило процесс интеграции новых сотрудников при переходе между проектами, замедлило внедрение нового функционала, а также привело к трудностям исправлениям корневых ошибок в программных продуктах.

Не менее важное значение имеет модуляризация и с экономической точки зрения. Внедряя модульные решения, компании могут сократить стоимость разработки продуктво за счет уменьшения дублирующейся работы, снизить затраты на тестирование, а также пересмотреть процессы найма сотрудников из-за упрощённой миграции разработчиков между проектами, так как архитектурная кодовая база и подходы не меняются.

\section{Цель и задачи работы}

Целью данной работы является проектирование и разработка набора модулей с унифицированным интерфейсом для мобильных приложений, который обеспечит стандартизацию процессов разработки, упростит интеграцию новых функций и снизит затраты на поддержку программных продуктов. В данной работе будет рассматриваться разработка группы модулей только для Android приложений. 

Задачи, которые будут решены, в рамках данной работы:
\begin{enumerate}
    \item Анализ существующих подходов; в данный этап входит изучение современных подходов мобильной разработки с учетом поддержки модульности, а также перечень базовых сценариев, которые должны быть спроектированы и реализованы для достижения заданной цели
    \item Проектирование выбранных модулей; в данный этап входит именно разработка структуры выбраных модулей, описание интерфейсов и их взаимодействия между собой в рамках описываемой области видимости.
    \item Реализация и интеграция предложенного функционала в реальный проект; в данный этап входит реализация описанных интерфейсов и подходов из этапа проектирования, вместе с описанием вспомогательных механизмов и инструментов для достижения желаемого результата. Кроме этого, обязательно необходимо провести внедрение реализованных решений для проверки работоспособности и тестируемости.
    \item Оценки эффективности предложенного решения; в данный этап входит выбор метрик для оценки решения, обоснование выбора этих метрик, а также сравнение ключевых значений со значениями метрик до интеграции.
\end{enumerate}

При достижении поставленных задач можно будет сделать вывод о достижении ключевой цели работы - реализация эффективного набора модулей для улучшения процессов создания Android приложений.


\section{Обзор существующих решений и их недостатки}\label{existingsols}
За последние годы разработка Android приложений претерпела значительные изменения, связанные с усложнением пользовательских сценариев, тенденции к созданию "SuperApp" приложений, что приводит к растущим требованиям гибкости, масштабируемости, а зачастую и адаптации к быстрым сменам вектора развития продукта. Важно понимать, что выбор архитектуры приложения и сформированных подходов к разработке напрямую влияет на его дальнейшую поддержку, возможность интеграции новых функций и общую стабильность продукта.

Проанализировав существующие решения, в этой главе постараемся выявить основные проблемы и трудности, с которыми сталкиваются рядовые разработчики мобильных приложениям, а также обоснуем необходимость внедрения и использования модульных подходов.

\subsection{Решения с монолитной архитектурой}
Монолитная архитектура — это традиционная модель разработки программного обеспечения, в которой одна база кода используется для выполнения нескольких бизнес-функций. Все программные компоненты монолитной системы взаимозависимы из-за использования встроенных механизмов обмена данными внутри системы.
В контексте мобильной разработки такой подход позволяет легко переиспользовать компоненты системы в рамках одного приложения, но за счет этого имеет ряд существенных недостатков:
\begin{enumerate}
    \item Невозможность переиспользования реализованных компонентов в рамках других проектов; компоненты в монолите не могут быть использованы нигде, кроме корневого модуля приложения. Это приводит к дублированию кода, увеличению времени разработки новых приложений, а также наличию различий в подходах к разработке среди команд и проектов.
    \item Гарантированная инвалидация кэшей сборки; так как модуль приложения единственный и содержит весь код продукта, то любое изменение кодовой базы приводит к пересборке полностью всего проекта. Это приводит к увеличению времени разработки, так как элементарно игнорируются кэши Gradle.
    \item Сложность интеграции разработчиков в продукт; в монолитной архитектуре попросту отсутствуют гарантированные механизмы разделения компонентов. Это приводит к сильной связанности кода, которая требует больше времени для понимания новыми сотрудниками из-за своей неинтуитивности. Сюда также можно отнести и проблему "Bus Factor" - это меры сосредоточения информации среди отдельных членов проекта.
\end{enumerate}
Стоит отметить, что монолитный подход как раз и являлся архитектурным решением для разработки мобильных приложений в компании Visify.

\subsection{Решения на основе MVVM}
Архитектура MVVM - это паттерн архитектуры, который разделяет приложение на три ключевых компонента: Model, View и ViewModel.
\begin{enumerate}
    \item Model - Здесь содержится бизнес-логика, обрабатываются данные, выполняются различные операции и взаимодействие с источниками данных.
    \item View - Здесь содержится пользовательский интерфейс (UI) приложения. View ответственен за отображение данных и реагирование на взаимодействие пользователя.
    \item ViewModel - является посредником между Model и View. Данный слой содержит логику, связанную с UI, и управляет состоянием приложения. ViewModel предоставляет данные, которые View отображает, и обрабатывает действия пользователя.
\end{enumerate}

Основное преимущество данного паттерна это разделение ответственности между объектами \textit{Presentation} слоя. Данная архитектура стала стандартом для разработки Android приложений, но в меняющемся мире мобильной разработки на данный момент имеет ряд недостатков:

\begin{enumerate}
    \item Сложность настройки и поддержания привязки данных; на комплексных экранах количество свойств, отвечающих за управление его состоянием стремительно растет, что усложняет его поддержку, добавление нового функционала, а также увеличивает рост количества ошибок и дефектов в моделях бизнес-логики.
    \item Слабая интеграция с декларативными UI фреймворками; набирающий популярность Jetpack Compose нуждается в едином объекте состояния экрана, а также единой точки входа в его бизнес-логику. MVVM в своём изначальном виде не может удовлетворить подобный запрос.
\end{enumerate}

\subsection{Использование собственных механизмов внедрения зависимостей}
Внедрение зависимости (Dependency Injection, DI) — процесс предоставления внешней зависимости программному компоненту. Является специфичной формой «инверсии управления», когда она применяется к управлению зависимостями. Данный паттерн является ключевым паттерном, который используется для повышения модульности и тестируемости программных систем на платформе Android.

В компании Visify использовалось самописное решение, для реализации этого паттерна. Решение было обусловлено маленькой кодовой базой, отсутствием необходимости в сложных механизмов DI, таких как модульность компонентов, контроль жизненным циклом объектов и графа зависимостей для тестового окружения. Это привело к ряду проблем:
\begin{enumerate}
    \item Большое количество шаблонного кода; с ростом кодовой базы конфигурация объектов требовала всё большее количество времени разработчика, хотя никакой бизнес-логики не содержала, поэтому ресурсы разработчиков использовались неэффективно.
    \item Сложность интеграции новых разработчиков; собственное решение отличается программным интерфейсов, что увеличивает время разработки нового функционала пришедшим сотрудником.
\end{enumerate}

\subsection{Использование стандартного механизма сборки Gradle}\label{gradlesol}
Gradle является основным инструментом сборки для Android приложений который предоставляет разработчикам гибкость в управлении зависимостями и организации структуры проекта. В стандартной конфигурации Gradle зависимости между модулями определяются через файлы \textit{build.gradle.kts}, где каждый модуль прописывает свои зависимости и их роли вручную.

При этом Gradle не предоставляет встроенных инструментов для определения логических типов модулей. Это может привести к следующим проблемам:
\begin{enumerate}
    \item Сильная связанность модулей между собой; без детерминированных проверок валидация корректности зависимости модулей между друг другом ложится на плечи разработчиков, проводящих оценку чужого кода, хотя этот процесс может быть легко автоматизирован, следовательно, уменьшено количество ошибок в модульной архитектуре всего приложения.
    \item Неправильная структура модулей приводит к увеличению времени сборки проекта; логическое разделение модулей на типы помогает минимизировать пересборку модулей и более эффективное использование кэшей за счет разделения интерфейсов и реализаций в рамках модульного графа.
\end{enumerate}

\subsection{Использование AndroidSdk в явном виде}\label{androidsdk}
AndroidSdk - это набор инструментов для разработки приложений под операционную систему Android. Данное Sdk предоставляет обширный набор инструментов и \textit{api} для работы с различными сценариями - разрешения, доступ до геолокации пользователя, работа с диском, сетью и так далее. Так как это базовый набор инструментов, то он обладает намного более широким спектром использований, чем зачастую нужно рядовому разработчику. Поэтому зачастую требуется реализовать набор "обёрток" для базовых сценариев, потому что:
\begin{enumerate}
    \item\label{sdkabstract} Избыток абстракций; не все сценарии взаимодействия с \textit{api} необходимо обрабатывать разработчику, поэтому лишние абстракции усложняют взаимодействия пользователя с данным Sdk.
    \item Комплексность сценариев; зачастую сценарии могут быть взаимосвязаны между собой (например: работа с геолокацией требует работы с системными разрешениями), что усугубляет проблему, описанную в пункте \ref{sdkabstract}
    \item Сложность тестирования; явное использование объектов Sdk приводит к зависимости модуля на AndroidSdk, что делает невозможным его покрытие unit-тестами.
\end{enumerate}

%% Chapter 2
\chapter{Анализ и обоснование разработки модульной системы}

\section{Проблемы подходов к разработке без модульного подхода}\label{existingsproblems}
Исходя из информации, приведенной в главе \ref{existingsols} можно сформировать следующий список проблем, с которыми сталкиваются разработчики, не придерживающиеся модульного подхода к разработке архитектуры приложений:
\begin{enumerate}
    \item Отсутствие возможности переиспользования компонентов между проектами, что приводит к дублированию кода и увеличению затрат на разработку и поддержку.
    \item Рост сложности кодовой базы, приводящий к увеличению времени на интеграцию новых сотрудников и усложнению сопровождения проекта.
    \item Увеличение времени сборки из-за отсутствия механизма кэширования отдельных модулей, что снижает общую производительность команды.
    \item Высокая связанность компонентов внутри проекта, затрудняющая внесение изменений и увеличивающая риск появления ошибок при рефакторинге.
    \item Ограниченные возможности тестирования, так как тесная зависимость модулей приводит к сложности написания модульных тестов и увеличивает время на их поддержку.
    \item Проблемы с масштабируемостью продукта, поскольку рост кодовой базы без четкой модульной структуры усложняет добавление новых функций и поддержку существующих.
    \item Отсутствие стандартизации архитектурных решений между командами, что приводит к разнице в подходах, усложняющей совместную работу над проектом.
    \item Сложности в адаптации к изменениям вектора развития продукта, поскольку высокая связанность кода делает реорганизацию системы дорогостоящей и трудоемкой.
\end{enumerate}

\section{Принципы модульного проектирования и их применение}
Формируя принципы модульного проектирования для мобильных приложений, можно опираться на принципы теории объектно-ориентированного программирования, так как эти они позволяют решить проблемы, описанные в главе \ref{existingsproblems}. Сформируем принципы модульного проектирования:
\begin{enumerate}
    \item \textbf{Инкапсуляция}; Данный принцип предполагает скрытие внутренней реализации модуля от его пользователей. Фактически, это подразумевает разделение модуля на 2 объекта
    \begin{enumerate}
        \item \textit{api} модуль - легковесный модуль, который не должен иметь зависимостей на AndroidSdk и другие модули, не являющиеся \textit{api} модулями.
        \item \textit{impl} модуль - реализация соответствующего \textit{api} модуля. Может влючать в себя инфраструктурные модули, любые \textit{api} модули, любые внешние зависимости
    \end{enumerate}
    \item \textbf{Разделение ответственности}; Данный принцип подразумевает, что в рамках модульного подхода стоить придерживаться логики, что каждый модуль должен отвечать только за одну конкретную задачу, будь то бизнес-логика (например: экран профиля пользователя) или решение ядра приложения (например: реализация сетевого взаимодействия). Это позволит создавать компоненты, которые могут быть разработаны независимо друг от друга, протестированы или заменены.
    \item \textbf{Повторное использование модулей}; Модули могут быть использованы в разных частях приложения и даже в различных проектах. Данный принцип поможет значительно сократить объем работ по созданию новых проектов, повысить эффективность разработки и снизить процент ошибок, так как переиспользованные модули уже протестированы и находятся в стабильном состоянии.
    \item \textbf{Тестируемость}; Данный принцип, благодаря слабой связанности между модулями, может позволить упростить процессы тестирования, поскольку в этом случае каждый модуль может быть протестирован отдельно от других. Немаловажно, что уменьшение количество зависимостей на AndroidSdk позволяет эффективнее автоматизировать данный процесс.
    
\end{enumerate}

\section{Требования к архитектуре модульной системы}\label{archrequirements}
TODO()

\section{Выбор технологий для реализации}
Исходя из требований, приведенных в главе \ref{archrequirements} мы можем сформировать список технологий, с помощью которых можем добиться желаемого результата.
\subsection{Система сборки Gradle}
Gradle является основным инструментом для сборки Android приложений. Данная система сборки работает на JVM, что делает его кроссплатформенным и позволяет использовать мощные механизмы кеширования для ускорения сборки проекта.

Одной из ключевых особенностей Gradle является поддержка Kotlin Scripts (KTS), что дает разработчикам возможность писать конфигурационные файлы на Kotlin, вместо устаревшего Groovy. Это делает код более читаемым, типобезопасным и удобным для рефакторинга, особенно в крупных проектах.

Кроме того, в Android разработчики могут гибко управлять тем, как объявляются модули в проекте. В этом помогает механизм buildSrc — специальный модуль внутри проекта, где можно определить кастомные DSL-обертки для зависимостей, конфигураций и плагинов. Это позволяет сделать структуру проекта более чистой, стандартизированной и удобной в поддержке, особенно если в команде работают несколько разработчиков.

\subsection{Внедрение зависимостей с помощью Hilt}
Dagger - это фреймворк для внедрения зависимостей в приложения на платформе Java и Android. Данный фреймворк работает за счет кодогенерации и процессинга аннотаций заданных компонентов, что позволяет уменьшить написание шаблонного кода. Dagger является достаточно мощным и универсальным инструментом, который позволяет управлять жизненным циклом компонентов, валидировать граф зависимостей на наличие циклов на этапе компиляции и предоставляет инструменты для создания графа для использования последнего в рамках тестовой инфраструктуры.

Hilt же является надстройкой над Dagger, оптимизированной для работы в Android приложениях. Hilt предоставляет заранее сконфигурированные аннотации для контроля жизненным циклом объектов графа, упрощенные точки инъекций зависимостей, а также удобную работу с ViewModel.

Тем не менее, Hilt остается достаточно комплексным инструментом, требующим формирования единого подхода по работе с DI в рамках проекта или группы проектов, чтобы избежать ошибок внутри графа и гарантировать внедрение зависимостей.

\subsection{Использование OkHttp для работы с сетью}\label{okhttp}
OkHttp является стандартной библиотекой для работы с Http запросами в Android приложениях. Однако, ситуация не сильно отличается от описанной в главе \ref{androidsdk} касательно AndroidSdk - библиотека достаточно обширная, а рядовому разработчику нет смысла погружаться в тонкости настройки сетевого клиента для разработки бизнес-логики. Важно также выделить настройку сетевого клиента в отдельный модуль, чтобы другие разработчики могли полноценно использовать уже настроеный OkHttpClient в своих приложениях, не теряя при этом необходимого инструментария. Предоставленный спроектированным модулем компонент должен соответствовать следующим функциональным требованиям:
\begin{enumerate}
    \item Поддержка Server-Sent-Events
    \item Механизм авторизации сетевых запросов
    \item Логирование запросов
    \item Подмена параметров запросов и ответов
    \item Правильная настройка заголовков и параметров
    \item Иметь возможность интегрировать пользовательские перехватчики запросов
    \item Механизм повторного выполнения запроса в случае неудачи
    \item Обработка сетевых ошибок
\end{enumerate}

\subsection{Архитектурный подход к управлению состоянием приложения}
Как архитектурный подход для \textit{Presentation} предлагается использовать архитектурный паттерн MVI (Model-View-Intent) - в рамках паттерна все данные проходят через однонаправленный поток: пользовательские действия (Intent) должны инициировать обновление данных в модели (Model), после чего представление (View) отображает измененные данные.
Если разбирать в сравнении с MVVM по слоям, то получим следующее:
\begin{enumerate}
    \item Model - не отличается от MVVM.
    \item View - на практике отличается представлением состояния для этого слоя. Для MVI характерен единый объект состояния - то есть State, в отличие от MVVM, в котором, как правило, каждое поле обслуживается самостоятельно.
    \item Intent - главное отличие сравниваемых подходов; в MVI Intent позволяет реализовать однонаправленный поток, что упрощает упорядочить данные и действия в системе, минимизируя тесную связанность между компонентами.
\end{enumerate}

\subsection{Навигация с помощью Cicerone}
Cicerone - библиотека, предназначенная для упрощения навигации между экранами в приложении. Она предоставляет удобную работу с навигационным стеком, позволяя организовать переходы через единый контроллер навигации. Это дает возможность инкапсулировать логику открытия экрана, позволяя использовать любой из доступных методов отображения UI - как Activity, так и Fragment. При этом, данная библиотека не зависит от выбранного UI фреймворка (в отличие NavController от Google) - можно использовать как императивный (Views), так и декларативный (Jetpack Compose) подходы. Сама реализация библиотеки является достаточно легковесной, не требующая дополнительных зависимостей в проект. Совокупность перечисленных выше факторов позволяет остановиться на данной библиотеке при выборе решения проблемы навигации.

\subsection{Jetpack Compose как UI фреймворк}
Jetpack Compose — это декларативный пользовательский интерфейс с открытым исходным кодом на основе Kotlin для Android, разработанный Google. Compose значительно улучшает процесс разработки UI за счет декларативного подхода, который упрощает комбинирование компонентов и делает код более модульным. Вместо сложных иерархий XML-разметки и ручного связывания представлений разработчики могут описывать UI как набор функций, которые легко комбинируются между собой. Это значительно ускоряет процесс создания интерфейсов и упрощает их поддержку.

Кроме того, Jetpack Compose требует меньше шаблонного кода, чем традиционный подход с View и RecyclerView, поскольку многие рутинные задачи, такие как управление состоянием или обновление интерфейса, автоматизированы, так как Compose сам позаботится об изменениях с помощью \textit{androidx.compose.runtime.State}.

Немаловажно и то, что Compose активно развивается, а его экосистема расширяется с каждым обновлением. Google регулярно выпускает новые версии, улучшая производительность, добавляя поддержку новых компонентов и упрощая интеграцию с другими инструментами Android-разработки. Это делает его перспективным выбором для современных мобильных приложений.

%% Chapter 3
\chapter{Проектирование выбранных модулей}
\section{Структура построения модульной системы}
Для решения проблем, описанных в главе \ref{gradlesol}, в ходе проектирования структуры постоения модульной системы получилось выделить три логических типа модулей:
\begin{enumerate}
    \item \textit{app} - это корневой модуль приложения. К нему должны подключаться все остальные модули и инициализироваться граф зависимостей. Ограничений на типы подключаемых модулей нет.
    \item \textit{core} - должен содержать компоненты ядра приложения, такие как: реализация сетевого взаимодействия, реализация работы с диском, логирование, сбор анатилики и так далее. Важно, что этот модуль должен зависеть только от внешних зависимостей (явное указание сторонних библиотек), либо от другого \textit{core} модуля.
    \item \textit{api} - должен содержать только интерфейсы и абстракции, которые определяют взаимодействие с конкретным функционалом. Данный модуль не должен содержать бизнес-логику, поэтому должен зависеть только от других \textit{api} модулей. Лучшей сценарием будет счиаться проектирование \textit{api} модуля без зависимости на AndroidSdk, но на практике это не всегда достижимо.
    \item \textit{impl} - модуль, содержащий специфичные функции приложения (например: экран профиля пользователя). Данный модуль может зависеть от \textit{api} и \textit{core} модулей, но не должен зависеть от других \textit{impl} модулей.
\end{enumerate}

При реализации подобной модульной структуры важно предоставить разработчикам возможность конфигурировать ключевые параметры своих модулей:
\begin{enumerate}
    \item Использование сторонних плагинов
    \item Единообразный подход к работе версионированию приложений
    \item Использование инструмента \textit{buildFeatures}, которая позволяет конфигурировать дополнительные опции для сборки (например: Compose процессор, \textit{CoreLibraryDesugaring})
\end{enumerate}


\section{Организация механизма внедрения зависимостей}
Вместо создания дополнительных абстракций или специфичных решений для DI будет использоваться стандартные инструменты, предоставляемые Hilt.
Основной акцент будет сделан создании руководства для разработки и использования Hilt, которое станет основой для всех участников разработки, обеспечивая единообразие и упрощение процесса внедрения зависимостей на всех этапах жизненного цикла приложения.
Предлагаемая структура документации:
\begin{enumerate}
    \item \textbf{Введение}; В данном блоке объясняется цель использования Hilt в проекте. Это поможет разработчикам понять, почему мы выбрали именно эту технологию для DI и как она интегрируется в наше приложение. 
    \item \textbf{Основные принципы};
        \begin{enumerate}
            \item Как управлять жизненным циклом зависимостей в приложении (описание стандартных и пользовательских @Scope в проекте)
            \item Правильное использование @Module и @InstallIn для объявления зависимостей
        \end{enumerate}
    \item \textbf{Как структурировать зависимости};
        \begin{enumerate}
            \item Как правильно организовывать зависимости между модулями.
            \item Рекоммендации по внедрению зависимостей внутри одного модуля.
        \end{enumerate}
    \item \textbf{Примеры кода};
        \begin{enumerate}
            \item Пример использования @Inject
            \item Пример создания модуля через @Module и @InstallIn
        \end{enumerate}
    \item \textbf{Стандартные ошибки и их решение};
    \item \textbf{Рекоммендации по тестированию};
\end{enumerate}

Реализовав подобный документ в удобном для проекта формате (в виде markdown файла или страницы в Confluence) можно получить удобное руководство для всех Android разработчиков компании, чтобы обеспечить стандартизированный подход к реализации DI в проектах.


\section{Проектирование сетевых модулей}
Исходя из требований, описанных в главе \ref{okhttp}, сетевые модули были декомпозированы следующим образом:
\begin{enumerate}
    \item \texttt{:net:http:api} - модуль, в котором определяются все интерфейсы, требуемые для инициализации модуля \texttt{:net:http:impl}
    \item \texttt{:net:http:impl} - модуль, в котором реализуется механизм сетевого взаимодействия с сервером.
    \item \texttt{:net:http:models} - модуль, в котором хранятся сгенерированные по схеме сервера модели данных.
    \item \texttt{:net:http:sse:api} - модуль, в котором определяются все интерфейсы для поддержки Server-Sent-Events.
    \item \texttt{:net:http:sse:impl} - модуль, в котором реализована логика поддержки Server-Sent-Events.
    
\end{enumerate}

\subsection{Проектирование модуля :net:http:api}
Так как данный модуль должен только отражать контракт взаимодействия с модулем реализации, то было принято решение выделить следующие интерфейсы:
\begin{enumerate}
    \item AppAuthListener - должен отвечать за уведомление об успешной или проваленной попытке авторизации.
    \item HttpClientProvider - интерфейс, предоставляющий настроенный OkHttpClient для использования.
    \item ForceAuthFilter - интерфейс, отвечающий за логику проверки необходимости форсирования экрана авторизации после неудачного сетевого запроса
    \item AuthRefreshService - интерфейс, предоставляет контракт для реализации механизма обновления токенов доступа
\end{enumerate}

\begin{algorithm}[!h]
\caption{Исходный код \texttt{AppAuthListener}}
\begin{lstlisting}
interface AppAuthListener { 
    fun onAuthSucceed()
    fun onAuthFailed() 
}
\end{lstlisting}
\end{algorithm}

\begin{algorithm}[!h]
\caption{Исходный код \texttt{HttpClientProvider}}
\begin{lstlisting}
interface HttpClientProvider {
   val client: OkHttpClient
}
\end{lstlisting}
\end{algorithm}

\begin{algorithm}[!h]
\caption{Исходный код \texttt{ForceAuthFilter}}
\begin{lstlisting}
interface ForceAuthFilter {
   fun isNeedToAuth(request: Request): Boolean
}
\end{lstlisting}
\end{algorithm}

\begin{algorithm}[!h]
\caption{Исходный код \texttt{AuthRefreshService}}
\begin{lstlisting}
interface AuthRefreshService {
   suspend fun refresh(
       access: String,
       refresh: String
   ): TokensResponse
}
\end{lstlisting}
\end{algorithm}

\subsection{Проектирование модуля :net:http:sse:api}
Так как данный модуль должен только отражать контракт взаимодействия с модулем реализации, то было принято решение выделить следующие интерфейсы:
\begin{enumerate}
    \item \texttt{ServerConnectionEngine} - интерфейс, отвечающий за запуск и остановку keep-alive соединения с сервером.
    \item \texttt{SseEventHandler} - интерфейс, отвечающий за обработку входящих событий с сервера.
\end{enumerate}

\begin{algorithm}[!h]
\caption{Исходный код \texttt{ServerConnectionEngine}}
\begin{lstlisting}
interface ServerConnectionEngine {
   val isRunning: Boolean
   fun start()
   fun stop()
}
\end{lstlisting}
\end{algorithm}

\begin{algorithm}[!h]
\caption{Исходный код \texttt{SseEventHandler}}
\begin{lstlisting}
interface SseEventHandler {
    fun handleEvent(payload: String)
}
\end{lstlisting}
\end{algorithm}

\subsection{Проектирование модуля :net:http:models}
Для обеспечения согласованности и снижения количества ошибок, связанных с ручным описанием моделей, применяется автоматическая генерация моделей данных на основе схем API бэкенда.
Модуль \texttt{:net:http:models} служит единым хранилищем этих моделей и обеспечивает централизованное представление всех используемых структур данных. Важно отметить, что механизм оптимизации R8 позволяет автоматически удалять неиспользуемые модели на этапе сборки релизных версий - это наиболее заметно в случае крупных \texttt{API}, содержащих сотни различных моделей, из которых в конкретном приложении может использоваться лишь небольшая часть.

\section{Проектирование инфраструктурных модулей}



\section{Проектирование архитектурного подхода к управлению состоянием приложения}

\section{Проектирование утилитарных модулей}

\section{Проектирование модулей пользовательского интерфейса и навигации}

%% Chapter 4
\chapter{Реализация выбранных модулей}

\section{Реализация механизма внедрения зависимостей}

\section{Реализация сетевых модулей}

\section{Реализация инфраструктурных модулей}

\section{Реализация архитектурного подхода к управлению состоянием приложения}

\section{Реализация утилитарных модулей}

\section{Реализация модулей пользовательского интерфейса и навигации}

\section{Интеграция и тестирование модульной системы}

%% Chapter 5
\chapter{Оценка эффективности решения}

\section{Методика оценки разработанного решения}

\section{Анализ полученных результатов}

\section{Выводы по эффективности и возможностям доработки}

\startconclusionpage

В данном разделе размещается заключение.

\end{document}
