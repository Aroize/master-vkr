\documentclass[specification,annotation,times]{itmo-student-thesis}

%% Опции пакета:
%% - specification - если есть, генерируется задание, иначе не генерируется
%% - annotation - если есть, генерируется аннотация, иначе не генерируется
%% - times - делает все шрифтом Times New Roman, собирается с помощью xelatex
%% - languages={...} - устанавливает перечень используемых языков. По умолчанию это {english,russian}.
%%                     Последний из языков определяет текст основного документа.

%% Делает запятую в формулах более интеллектуальной, например:
%% $1,5x$ будет читаться как полтора икса, а не один запятая пять иксов.
%% Однако если написать $1, 5x$, то все будет как прежде.
\usepackage{icomma}

%% Один из пакетов, позволяющий делать таблицы на всю ширину текста.
\usepackage{tabularx}

%% Данные пакеты необязательны к использованию в бакалаврских/магистерских
%% Они нужны для иллюстративных целей
%% Начало
\usepackage{tikz}
\usetikzlibrary{arrows}
\usepackage{filecontents}
\begin{filecontents}{master-thesis.bib}
\end{filecontents}
%% Конец

%% Указываем файл с библиографией.
\addbibresource{master-thesis.bib}

\begin{document}

\studygroup{M4200C}
\title{Проектирование и реализация набора модулей c унифицированным интерфейсом для разработки группы мобильных приложений}
\author{Ильменский Илья Андреевич}{Ильменский И.А.}
\supervisor{Пономарёв Вадим Анатольевич}{Пономарёв В.А.}{доцент}{факультет информационных технологий и программирования}
\publishyear{2025}
%% Дата выдачи задания. Можно не указывать, тогда надо будет заполнить от руки.
\startdate{01}{марта}{2025}
%% Срок сдачи студентом работы. Можно не указывать, тогда надо будет заполнить от руки.
\finishdate{31}{мая}{2025}
%% Дата защиты. Можно не указывать, тогда надо будет заполнить от руки.
\defencedate{15}{июня}{2019}

\addconsultant{TODO()}{TODO()}
\addconsultant{TODO()}{TODO()}

\secretary{Штумпф С. А.}

%% Задание
%%% Техническое задание и исходные данные к работе
\technicalspec{TODO()}

%%% Содержание выпускной квалификационной работы (перечень подлежащих разработке вопросов)
\plannedcontents{TODO()}

%%% Исходные материалы и пособия 
\plannedsources{\begin{enumerate}
    Исходные материалы и пособия работой не предусмотрены
\end{enumerate}}

%%% Цель исследования
\researchaim{TODO()}

%%% Задачи, решаемые в ВКР
\researchtargets{\begin{enumerate}
    \item TODO()
\end{enumerate}}

%%% Использование современных пакетов компьютерных программ и технологий
\addadvancedsoftware{TODO()}

%%% Краткая характеристика полученных результатов 
\researchsummary{TODO()}

%%% Гранты, полученные при выполнении работы 
\researchfunding{TODO()}

%% Эта команда генерирует титульный лист и аннотацию.
\maketitle{Магистр}

%% Оглавление
\tableofcontents

%% Макрос для введения. Совместим со старым стилевиком.
\startprefacepage

В данном разделе размещается введение.

%% Начало содержательной части.
\chapter{Постановка задачи}

\section{Актуальность темы}

В настоящее время компании расширяют ассортимент поддерживаемых продуктов и решений, что приводит к ряду организационных и технических вызовов. В частности, отсутствие унифицированного базовой функциональностью между различными продуктами способствует увеличению сроков их разработки (Delivery). Это также приводит к повторному возникновению и решению одних и тех же проблем внутри одной компании, что снижает эффективность разработки.

Описанная проблема не обошла стороной компанию Visify. Отсутствие стандартов к написанию кода, а также отсутствие общей кодовой базы для базовых решений на нескольких проектах привело к значительным объемам дублирования функциональности. В конечном итоге, это усложнило процесс интеграции новых сотрудников при переходе между проектами, замедлило внедрение новых функциональностей, а также привело к трудностям исправлениям корневых ошибок в программных продуктах.

Не менее важное значение имеет модуляризация и с экономической точки зрения. Внедряя модульные решения, компании могут сократить стоимость разработки продуктво за счет уменьшения дублирующейся работы, снизить затраты на тестирование, а также пересмотреть процессы найма сотрудников из-за упрощённой миграции разработчиков между проектами, так как архитектурная кодовая база и подходы не меняются.

\section{Цель и задачи работы}

Целью данной работы является проектирование и разработка набора модулей с унифицированным интерфейсом для мобильных приложений, который обеспечит стандартизацию процессов разработки, упростит интеграцию новых функций и снизит затраты на поддержку программных продуктов. В данной работе будет рассматриваться разработка группы модулей только для Android приложений. 

Задачи, которые будут решены, в рамках данной работы:
\begin{enumerate}
    \item Анализ существующих подходов; в данный этап входит изучение современных подходов мобильной разработки с учетом поддержки модульности, а также перечень базовых сценариев, которые должны быть спроектированы и реализованы для достижения заданной цели
    \item Проектирование выбранных модулей; в данный этап входит именно разработка структуры выбраных модулей, описание интерфейсов и их взаимодействия между собой в рамках описываемой области видимости.
    \item Реализация и интеграция предложенной функциональности в реальный проект; в данный этап входит реализация описанных интерфейсов и подходов из этапа проектирования, вместе с описанием вспомогательных механизмов и инструментов для достижения желаемого результата. Кроме этого, обязательно необходимо провести внедрение реализованных решений для проверки работоспособности и тестируемости.
    \item Оценки эффективности предложенного решения; в данный этап входит выбор метрик для оценки решения, обоснование выбора этих метрик, а также сравнение ключевых значений со значениями метрик до интеграции.
\end{enumerate}

При достижении поставленных задач можно будет сделать вывод о достижении ключевой цели работы - реализация эффективного набора модулей для улучшения процессов создания Android приложений.


\section{Обзор существующих решений и их недостатки}\label{existingsols}
За последние годы разработка Android приложений претерпела значительные изменения, связанные с усложнением пользовательских сценариев, тенденции к созданию "SuperApp" приложений, что приводит к растущим требованиям гибкости, масштабируемости, а зачастую и адаптации к быстрым сменам вектора развития продукта. Важно понимать, что выбор архитектуры приложения и сформированных подходов к разработке напрямую влияет на его дальнейшую поддержку, возможность интеграции новых функций и общую стабильность продукта.

Проанализировав существующие решения, в этой главе постараемся выявить основные проблемы и трудности, с которыми сталкиваются рядовые разработчики мобильных приложениям, а также обоснуем необходимость внедрения и использования модульных подходов.

\subsection{Решения с монолитной архитектурой}
Монолитная архитектура — это традиционная модель разработки программного обеспечения, в которой одна база кода используется для выполнения нескольких бизнес-функций. Все программные компоненты монолитной системы взаимозависимы из-за использования встроенных механизмов обмена данными внутри системы.
В контексте мобильной разработки такой подход позволяет легко переиспользовать компоненты системы в рамках одного приложения, но за счет этого имеет ряд существенных недостатков:
\begin{enumerate}
    \item Невозможность переиспользования реализованных компонентов в рамках других проектов; компоненты в монолите не могут быть использованы нигде, кроме корневого модуля приложения. Это приводит к дублированию кода, увеличению времени разработки новых приложений, а также наличию различий в подходах к разработке среди команд и проектов.
    \item Гарантированная инвалидация кэшей сборки; так как модуль приложения единственный и содержит весь код продукта, то любое изменение кодовой базы приводит к пересборке полностью всего проекта. Это приводит к увеличению времени разработки, так как элементарно игнорируются кэши Gradle.
    \item Сложность интеграции разработчиков в продукт; в монолитной архитектуре попросту отсутствуют гарантированные механизмы разделения компонентов. Это приводит к сильной связанности кода, которая требует больше времени для понимания новыми сотрудниками из-за своей неинтуитивности. Сюда также можно отнести и проблему "Bus Factor" - это меры сосредоточения информации среди отдельных членов проекта.
\end{enumerate}
Стоит отметить, что монолитный подход как раз и являлся архитектурным решением для разработки мобильных приложений в компании Visify.

\subsection{Решения на основе MVVM}
Архитектура MVVM - это паттерн архитектуры, который разделяет приложение на три ключевых компонента: Model, View и ViewModel.
\begin{enumerate}
    \item Model - Здесь содержится бизнес-логика, обрабатываются данные, выполняются различные операции и взаимодействие с источниками данных.
    \item View - Здесь содержится пользовательский интерфейс (UI) приложения. View ответственен за отображение данных и реагирование на взаимодействие пользователя.
    \item ViewModel - является посредником между Model и View. Данный слой содержит логику, связанную с UI, и управляет состоянием приложения. ViewModel предоставляет данные, которые View отображает, и обрабатывает действия пользователя.
\end{enumerate}

Основное преимущество данного паттерна это разделение ответственности между объектами \textit{Presentation} слоя. Данная архитектура стала стандартом для разработки Android приложений, но в меняющемся мире мобильной разработки на данный момент имеет ряд недостатков:

\begin{enumerate}
    \item Сложность настройки и поддержания привязки данных; на комплексных экранах количество свойств, отвечающих за управление его состоянием стремительно растет, что усложняет его поддержку, добавление новой функциональности, а также увеличивает рост количества ошибок и дефектов в моделях бизнес-логики.
    \item Слабая интеграция с декларативными UI фреймворками; набирающий популярность Jetpack Compose нуждается в едином объекте состояния экрана, а также единой точки входа в его бизнес-логику. MVVM в своём изначальном виде не может удовлетворить подобный запрос.
\end{enumerate}

\subsection{Использование собственных механизмов внедрения зависимостей}
Внедрение зависимости (Dependency Injection, DI) — процесс предоставления внешней зависимости программному компоненту. Является специфичной формой «инверсии управления», когда она применяется к управлению зависимостями. Данный паттерн является ключевым паттерном, который используется для повышения модульности и тестируемости программных систем на платформе Android.

В компании Visify использовалось самописное решение, для реализации этого паттерна. Решение было обусловлено маленькой кодовой базой, отсутствием необходимости в сложных механизмов DI, таких как модульность компонентов, контроль жизненным циклом объектов и графа зависимостей для тестового окружения. Это привело к ряду проблем:
\begin{enumerate}
    \item Большое количество шаблонного кода; с ростом кодовой базы конфигурация объектов требовала всё большее количество времени разработчика, хотя никакой бизнес-логики не содержала, поэтому ресурсы разработчиков использовались неэффективно.
    \item Сложность интеграции новых разработчиков; собственное решение отличается программным интерфейсов, что увеличивает время разработки новой функциональности пришедшим сотрудником.
\end{enumerate}

\subsection{Использование стандартного механизма сборки Gradle}\label{gradlesol}
Gradle является основным инструментом сборки для Android приложений который предоставляет разработчикам гибкость в управлении зависимостями и организации структуры проекта. В стандартной конфигурации Gradle зависимости между модулями определяются через файлы \textit{build.gradle.kts}, где каждый модуль прописывает свои зависимости и их роли вручную.

При этом Gradle не предоставляет встроенных инструментов для определения логических типов модулей. Это может привести к следующим проблемам:
\begin{enumerate}
    \item Сильная связанность модулей между собой; без детерминированных проверок валидация корректности зависимости модулей между друг другом ложится на плечи разработчиков, проводящих оценку чужого кода, хотя этот процесс может быть легко автоматизирован, следовательно, уменьшено количество ошибок в модульной архитектуре всего приложения.
    \item Неправильная структура модулей приводит к увеличению времени сборки проекта; логическое разделение модулей на типы помогает минимизировать пересборку модулей и более эффективное использование кэшей за счет разделения интерфейсов и реализаций в рамках модульного графа.
\end{enumerate}

\subsection{Использование AndroidSdk в явном виде}\label{androidsdk}
AndroidSdk - это набор инструментов для разработки приложений под операционную систему Android. Данное Sdk предоставляет обширный набор инструментов и \textit{api} для работы с различными сценариями - разрешения, доступ до геолокации пользователя, работа с диском, сетью и так далее. Так как это базовый набор инструментов, то он обладает намного более широким спектром использований, чем зачастую нужно рядовому разработчику. Поэтому зачастую требуется реализовать набор "обёрток" для базовых сценариев, потому что:
\begin{enumerate}
    \item\label{sdkabstract} Избыток абстракций; не все сценарии взаимодействия с \textit{api} необходимо обрабатывать разработчику, поэтому лишние абстракции усложняют взаимодействия пользователя с данным Sdk.
    \item Комплексность сценариев; зачастую сценарии могут быть взаимосвязаны между собой (например: работа с геолокацией требует работы с системными разрешениями), что усугубляет проблему, описанную в пункте \ref{sdkabstract}\label{sdkcomplex}
    \item Сложность тестирования; явное использование объектов Sdk приводит к зависимости модуля на AndroidSdk, что делает невозможным его покрытие unit-тестами.
\end{enumerate}

%% Chapter 2
\chapter{Анализ и обоснование разработки модульной системы}

\section{Проблемы подходов к разработке без модульного подхода}\label{existingsproblems}
Исходя из информации, приведенной в главе \ref{existingsols} можно сформировать следующий список проблем, с которыми сталкиваются разработчики, не придерживающиеся модульного подхода к разработке архитектуры приложений:
\begin{enumerate}
    \item Отсутствие возможности переиспользования компонентов между проектами, что приводит к дублированию кода и увеличению затрат на разработку и поддержку.
    \item Рост сложности кодовой базы, приводящий к увеличению времени на интеграцию новых сотрудников и усложнению сопровождения проекта.
    \item Увеличение времени сборки из-за отсутствия механизма кэширования отдельных модулей, что снижает общую производительность команды.
    \item Высокая связанность компонентов внутри проекта, затрудняющая внесение изменений и увеличивающая риск появления ошибок при рефакторинге.
    \item Ограниченные возможности тестирования, так как тесная зависимость модулей приводит к сложности написания модульных тестов и увеличивает время на их поддержку.
    \item Проблемы с масштабируемостью продукта, поскольку рост кодовой базы без четкой модульной структуры усложняет добавление новых функций и поддержку существующих.
    \item Отсутствие стандартизации архитектурных решений между командами, что приводит к разнице в подходах, усложняющей совместную работу над проектом.
    \item Сложности в адаптации к изменениям вектора развития продукта, поскольку высокая связанность кода делает реорганизацию системы дорогостоящей и трудоемкой.
\end{enumerate}

\section{Принципы модульного проектирования и их применение}
Формируя принципы модульного проектирования для мобильных приложений, можно опираться на принципы теории объектно-ориентированного программирования, так как эти они позволяют решить проблемы, описанные в главе \ref{existingsproblems}. Сформируем принципы модульного проектирования:
\begin{enumerate}
    \item \textbf{Инкапсуляция}; Данный принцип предполагает скрытие внутренней реализации модуля от его пользователей. Фактически, это подразумевает разделение модуля на 2 объекта
    \begin{enumerate}
        \item \textit{api} модуль - легковесный модуль, который не должен иметь зависимостей на AndroidSdk и другие модули, не являющиеся \textit{api} модулями.
        \item \textit{impl} модуль - реализация соответствующего \textit{api} модуля. Может влючать в себя инфраструктурные модули, любые \textit{api} модули, любые внешние зависимости
    \end{enumerate}
    \item \textbf{Разделение ответственности}; Данный принцип подразумевает, что в рамках модульного подхода стоить придерживаться логики, что каждый модуль должен отвечать только за одну конкретную задачу, будь то бизнес-логика (например: экран профиля пользователя) или решение ядра приложения (например: реализация сетевого взаимодействия). Это позволит создавать компоненты, которые могут быть разработаны независимо друг от друга, протестированы или заменены.
    \item \textbf{Повторное использование модулей}; Модули могут быть использованы в разных частях приложения и даже в различных проектах. Данный принцип поможет значительно сократить объем работ по созданию новых проектов, повысить эффективность разработки и снизить процент ошибок, так как переиспользованные модули уже протестированы и находятся в стабильном состоянии.
    \item \textbf{Тестируемость}; Данный принцип, благодаря слабой связанности между модулями, может позволить упростить процессы тестирования, поскольку в этом случае каждый модуль может быть протестирован отдельно от других. Немаловажно, что уменьшение количество зависимостей на AndroidSdk позволяет эффективнее автоматизировать данный процесс.
    
\end{enumerate}

\section{Требования к архитектуре модульной системы}\label{archrequirements}
TODO()

\section{Выбор технологий для реализации}
Исходя из требований, приведенных в главе \ref{archrequirements} мы можем сформировать список технологий, с помощью которых можем добиться желаемого результата.
\subsection{Система сборки Gradle}
Gradle является основным инструментом для сборки Android приложений. Данная система сборки работает на JVM, что делает его кроссплатформенным и позволяет использовать мощные механизмы кеширования для ускорения сборки проекта.

Одной из ключевых особенностей Gradle является поддержка Kotlin Scripts (KTS), что дает разработчикам возможность писать конфигурационные файлы на Kotlin, вместо устаревшего Groovy. Это делает код более читаемым, типобезопасным и удобным для рефакторинга, особенно в крупных проектах.

Кроме того, в Android разработчики могут гибко управлять тем, как объявляются модули в проекте. В этом помогает механизм buildSrc — специальный модуль внутри проекта, где можно определить кастомные DSL-обертки для зависимостей, конфигураций и плагинов. Это позволяет сделать структуру проекта более чистой, стандартизированной и удобной в поддержке, особенно если в команде работают несколько разработчиков.

\subsection{Внедрение зависимостей с помощью Hilt}
Dagger - это фреймворк для внедрения зависимостей в приложения на платформе Java и Android. Данный фреймворк работает за счет кодогенерации и процессинга аннотаций заданных компонентов, что позволяет уменьшить написание шаблонного кода. Dagger является достаточно мощным и универсальным инструментом, который позволяет управлять жизненным циклом компонентов, валидировать граф зависимостей на наличие циклов на этапе компиляции и предоставляет инструменты для создания графа для использования последнего в рамках тестовой инфраструктуры.

Hilt же является надстройкой над Dagger, оптимизированной для работы в Android приложениях. Hilt предоставляет заранее сконфигурированные аннотации для контроля жизненным циклом объектов графа, упрощенные точки инъекций зависимостей, а также удобную работу с ViewModel.

Тем не менее, Hilt остается достаточно комплексным инструментом, требующим формирования единого подхода по работе с DI в рамках проекта или группы проектов, чтобы избежать ошибок внутри графа и гарантировать внедрение зависимостей.

\subsection{Использование OkHttp для работы с сетью}\label{okhttp}
OkHttp является стандартной библиотекой для работы с Http запросами в Android приложениях. Однако, ситуация не сильно отличается от описанной в главе \ref{androidsdk} касательно AndroidSdk - библиотека достаточно обширная, а рядовому разработчику нет смысла погружаться в тонкости настройки сетевого клиента для разработки бизнес-логики. Важно также выделить настройку сетевого клиента в отдельный модуль, чтобы другие разработчики могли полноценно использовать уже настроеный OkHttpClient в своих приложениях, не теряя при этом необходимого инструментария. Предоставленный спроектированным модулем компонент должен соответствовать следующим функциональным требованиям:
\begin{enumerate}
    \item Поддержка Server-Sent-Events
    \item Механизм авторизации сетевых запросов
    \item Логирование запросов
    \item Подмена параметров запросов и ответов
    \item Правильная настройка заголовков и параметров
    \item Иметь возможность интегрировать пользовательские перехватчики запросов
    \item Механизм повторного выполнения запроса в случае неудачи
    \item Обработка сетевых ошибок
\end{enumerate}

\subsection{Архитектурный подход к управлению состоянием приложения}\label{mvi}
Как архитектурный подход для \textit{Presentation} предлагается использовать архитектурный паттерн MVI (Model-View-Intent) - в рамках паттерна все данные проходят через однонаправленный поток: пользовательские действия (Intent) должны инициировать обновление данных в модели (Model), после чего представление (View) отображает измененные данные.
Если разбирать в сравнении с MVVM по слоям, то получим следующее:
\begin{enumerate}
    \item Model - не отличается от MVVM.
    \item View - на практике отличается представлением состояния для этого слоя. Для MVI характерен единый объект состояния - то есть State, в отличие от MVVM, в котором, как правило, каждое поле обслуживается самостоятельно.
    \item Intent - главное отличие сравниваемых подходов; в MVI Intent позволяет реализовать однонаправленный поток, что упрощает упорядочить данные и действия в системе, минимизируя тесную связанность между компонентами.
\end{enumerate}

\subsection{Навигация с помощью Cicerone}
Cicerone - библиотека, предназначенная для упрощения навигации между экранами в приложении. Она предоставляет удобную работу с навигационным стеком, позволяя организовать переходы через единый контроллер навигации. Это дает возможность инкапсулировать логику открытия экрана, позволяя использовать любой из доступных методов отображения UI - как Activity, так и Fragment. При этом, данная библиотека не зависит от выбранного UI фреймворка (в отличие NavController от Google) - можно использовать как императивный (Views), так и декларативный (Jetpack Compose) подходы. Сама реализация библиотеки является достаточно легковесной, не требующая дополнительных зависимостей в проект. Совокупность перечисленных выше факторов позволяет остановиться на данной библиотеке при выборе решения проблемы навигации.

\subsection{Jetpack Compose как UI фреймворк}
Jetpack Compose — это декларативный пользовательский интерфейс с открытым исходным кодом на основе Kotlin для Android, разработанный Google. Compose значительно улучшает процесс разработки UI за счет декларативного подхода, который упрощает комбинирование компонентов и делает код более модульным. Вместо сложных иерархий XML-разметки и ручного связывания представлений разработчики могут описывать UI как набор функций, которые легко комбинируются между собой. Это значительно ускоряет процесс создания интерфейсов и упрощает их поддержку.

Кроме того, Jetpack Compose требует меньше шаблонного кода, чем традиционный подход с View и RecyclerView, поскольку многие рутинные задачи, такие как управление состоянием или обновление интерфейса, автоматизированы, так как Compose сам позаботится об изменениях с помощью \textit{androidx.compose.runtime.State}.

Немаловажно и то, что Compose активно развивается, а его экосистема расширяется с каждым обновлением. Google регулярно выпускает новые версии, улучшая производительность, добавляя поддержку новых компонентов и упрощая интеграцию с другими инструментами Android-разработки. Это делает его перспективным выбором для современных мобильных приложений.

%% Chapter 3
\chapter{Проектирование выбранных модулей}
\section{Структура построения модульной системы}\label{forma}
Для решения проблем, описанных в главе \ref{gradlesol}, в ходе проектирования структуры постоения модульной системы получилось выделить три логических типа модулей:
\begin{enumerate}
    \item \textit{app} - это корневой модуль приложения. К нему должны подключаться все остальные модули и инициализироваться граф зависимостей. Ограничений на типы подключаемых модулей нет.
    \item \textit{core} - должен содержать компоненты ядра приложения, такие как: реализация сетевого взаимодействия, реализация работы с диском, логирование, сбор анатилики и так далее. Важно, что этот модуль должен зависеть только от внешних зависимостей (явное указание сторонних библиотек), либо от другого \textit{core} модуля.
    \item \textit{api} - должен содержать только интерфейсы и абстракции, которые определяют взаимодействие с конкретной функциональностью. Данный модуль не должен содержать бизнес-логику, поэтому должен зависеть только от других \textit{api} модулей. Лучшей сценарием будет счиаться проектирование \textit{api} модуля без зависимости на AndroidSdk, но на практике это не всегда достижимо.
    \item \textit{impl} - модуль, содержащий специфичные функции приложения (например: экран профиля пользователя). Данный модуль может зависеть от \textit{api} и \textit{core} модулей, но не должен зависеть от других \textit{impl} модулей.
\end{enumerate}

При реализации подобной модульной структуры важно предоставить разработчикам возможность конфигурировать ключевые параметры своих модулей:
\begin{enumerate}
    \item Использование сторонних плагинов
    \item Единообразный подход к работе версионированию приложений
    \item Использование инструмента \textit{buildFeatures}, которая позволяет конфигурировать дополнительные опции для сборки (например: Compose процессор, \textit{CoreLibraryDesugaring})
\end{enumerate}


\section{Организация механизма внедрения зависимостей}\label{di}
Вместо создания дополнительных абстракций или специфичных решений для DI будет использоваться стандартные инструменты, предоставляемые Hilt.
Основной акцент будет сделан создании руководства для разработки и использования Hilt, которое станет основой для всех участников разработки, обеспечивая единообразие и упрощение процесса внедрения зависимостей на всех этапах жизненного цикла приложения.
Предлагаемая структура документации:
\begin{enumerate}
    \item\label{di:first} \textbf{Введение}; В данном блоке объясняется цель использования Hilt в проекте. Это поможет разработчикам понять, почему мы выбрали именно эту технологию для DI и как она интегрируется в наше приложение. 
    \item\label{di:second} \textbf{Основные принципы};
        \begin{enumerate}
            \item Как управлять жизненным циклом зависимостей в приложении (описание стандартных и пользовательских @Scope в проекте)
            \item Правильное использование @Module и @InstallIn для объявления зависимостей
        \end{enumerate}
    \item\label{di:third} \textbf{Как структурировать зависимости};
        \begin{enumerate}
            \item Как правильно организовывать зависимости между модулями.
            \item Рекоммендации по внедрению зависимостей внутри одного модуля.
        \end{enumerate}
    \item\label{di:fourth} \textbf{Примеры кода};
        \begin{enumerate}
            \item Пример использования @Inject
            \item Пример создания модуля через @Module и @InstallIn
        \end{enumerate}
    \item\label{di:fifth} \textbf{Стандартные ошибки и их решение};
    \item\label{di:sixth} \textbf{Рекоммендации по тестированию};
\end{enumerate}

Реализовав подобный документ в удобном для проекта формате (в виде markdown файла или страницы в Confluence) можно получить удобное руководство для всех Android разработчиков компании, чтобы обеспечить стандартизированный подход к реализации DI в проектах.


\section{Проектирование сетевых модулей}
Исходя из требований, описанных в главе \ref{okhttp}, сетевые модули были декомпозированы следующим образом:
\begin{enumerate}
    \item \texttt{:net:http:api} - модуль, в котором определяются все интерфейсы, требуемые для инициализации модуля \texttt{:net:http:impl}
    \item \texttt{:net:http:impl} - модуль, в котором реализуется механизм сетевого взаимодействия с сервером.
    \item \texttt{:net:http:models} - модуль, в котором хранятся сгенерированные по схеме сервера модели данных.
    \item \texttt{:net:http:sse:api} - модуль, в котором определяются все интерфейсы для поддержки Server-Sent-Events.
    \item \texttt{:net:http:sse:impl} - модуль, в котором реализована логика поддержки Server-Sent-Events.
    
\end{enumerate}

\subsection{Проектирование модуля :net:http:api}
Так как данный модуль должен только отражать контракт взаимодействия с модулем реализации, то было принято решение выделить следующие интерфейсы:
\begin{enumerate}
    \item AppAuthListener - должен отвечать за уведомление об успешной или проваленной попытке авторизации.
    \item HttpClientProvider - интерфейс, предоставляющий настроенный OkHttpClient для использования.
    \item ForceAuthFilter - интерфейс, отвечающий за логику проверки необходимости форсирования экрана авторизации после неудачного сетевого запроса
    \item AuthRefreshService - интерфейс, предоставляет контракт для реализации механизма обновления токенов доступа
\end{enumerate}

\begin{algorithm}[!h]
\caption{Исходный код \texttt{AppAuthListener}}
\begin{lstlisting}
interface AppAuthListener { 
    fun onAuthSucceed()
    fun onAuthFailed() 
}
\end{lstlisting}
\end{algorithm}

\begin{algorithm}[!h]
\caption{Исходный код \texttt{HttpClientProvider}}
\begin{lstlisting}
interface HttpClientProvider {
   val client: OkHttpClient
}
\end{lstlisting}
\end{algorithm}

\begin{algorithm}[!h]
\caption{Исходный код \texttt{ForceAuthFilter}}
\begin{lstlisting}
interface ForceAuthFilter {
   fun isNeedToAuth(request: Request): Boolean
}
\end{lstlisting}
\end{algorithm}

\begin{algorithm}[!h]
\caption{Исходный код \texttt{AuthRefreshService}}
\begin{lstlisting}
interface AuthRefreshService {
   suspend fun refresh(
       access: String,
       refresh: String
   ): TokensResponse
}
\end{lstlisting}
\end{algorithm}

\subsection{Проектирование модуля :net:http:sse:api}
Так как данный модуль должен только отражать контракт взаимодействия с модулем реализации, то было принято решение выделить следующие интерфейсы:
\begin{enumerate}
    \item \texttt{ServerConnectionEngine} - интерфейс, отвечающий за запуск и остановку keep-alive соединения с сервером.
    \item \texttt{SseEventHandler} - интерфейс, отвечающий за обработку входящих событий с сервера.
\end{enumerate}

\begin{algorithm}[!h]
\caption{Исходный код \texttt{ServerConnectionEngine}}
\begin{lstlisting}
interface ServerConnectionEngine {
   val isRunning: Boolean
   fun start()
   fun stop()
}
\end{lstlisting}
\end{algorithm}

\begin{algorithm}[!h]
\caption{Исходный код \texttt{SseEventHandler}}
\begin{lstlisting}
interface SseEventHandler {
    fun handleEvent(payload: String)
}
\end{lstlisting}
\end{algorithm}

\subsection{Проектирование модуля :net:http:models}
Для обеспечения согласованности и снижения количества ошибок, связанных с ручным описанием моделей, применяется автоматическая генерация моделей данных на основе схем API бэкенда.
Модуль \texttt{:net:http:models} служит единым хранилищем этих моделей и обеспечивает централизованное представление всех используемых структур данных. Важно отметить, что механизм оптимизации R8 позволяет автоматически удалять неиспользуемые модели на этапе сборки релизных версий - это наиболее заметно в случае крупных \texttt{API}, содержащих сотни различных моделей, из которых в конкретном приложении может использоваться лишь небольшая часть.

\section{Проектирование инфраструктурных модулей}

В данной работе, говоря об инфраструктурных модулях, подразумевается набор независимых модулей, позволяющие реализовать ключевые технические задачи проекта без привязки к конкретной бизнес-логике, но при этом достаточно высокоуровневые. Модули будут отвечать за работу с асинхронностью, системой сборки, унификацию работы со временем, файлами настроек, а также с конфигурацией приложения.

\subsection{Модуль для работы с корутинами}\label{coroutines}
Основной проблемой, которая была вызвана отсутствием подобного модуля в проекте, являлось то, что \texttt{Dispatchers} явно использовались напрямую в коде на всех слоях приложения. Это привело к тому, что покрыть юнит-тестами часть классов было невозможно, так как они явно использовали \texttt{Dispatchers.Main} и \texttt{Dispatchers.Main.immediate}. Для решения этой проблемы было принято выделить модуль, который бы позволял инкапсулировать неободимые \texttt{Dispatcher'ы}.

\begin{algorithm}[!h]
\caption{Исходный код \texttt{CoroutineDispatchers}}
\begin{lstlisting}
interface CoroutineDispatchers {
   val main: CoroutineDispatcher
   val io: CoroutineDispatcher
   val default: CoroutineDispatcher
}
\end{lstlisting}
\end{algorithm}
В тестах же предлагается использовать \texttt{TestFixtures}, позволяющий переопределять нужный \texttt{Dispatcher} на \texttt{Unconfined}, что дает возможность выполнять корутины синхронно и исключает потенциальные гонки данных.

\subsection{Использование buildSrc для унифицированной конфигурации проекта}
Для обеспечения гибкой настройки сборки проекта, \texttt{Gradle} предоставляет
механизм \texttt{buildSrc}, который позволяет хранить и управлять общими настройками, зависимостями и конфигурациями сборки в одном месте. С его помощью можно определить кастомные \texttt{DSL-обертки}, упрощающие поддержку проекта.

В соответствии с требованиями, описанными в главе \ref{forma}, выделим четыре \texttt{DSL-обертки}:
\begin{enumerate}
    \item \texttt{androidApp} - для конфигурации главного модуля приложения. Должен позволять настраивать манифест, управлять подписью приложения, настраивать обфускацирование и \texttt{proguard}.
    \item \texttt{androidApi} - для объявления \texttt{API} модуля, содержащего исключительно интерфейсы и контракты взаимодействия объектов.
    \item \texttt{androidCore} - для объявления модулей ядра приложения. Все модули, не связанный с бизнес-логикой, должны быть определены именно этой \texttt{DSL-оберткой}.
    \item \texttt{androidImpl} - для объявления модуля, содержащего бизнес-логику конкретной функциональности.
\end{enumerate}

\subsection{Модуль для работы со временем}
Отсутствие подобного модуля в проекте, привела к аналогичной проблеме, которая была описана в главе \ref{coroutines}. Из-за явного использования \texttt{LocalTime::now} и \texttt{LocalDateTime::now}, часть классов в проекте, которые так или иначе работают с текущим временем, покрыть было невозможно. Более того, часть классов использовала устаревший подход работы со временем, используя \texttt{java.util.Date} из-за ограничений \texttt{Android API}, так как стандартные классы \texttt{java.time} недоступны на ранних версиях без дополнительной поддержки. Для данного модуля важно определить подход к работе со временем в проекте и предоставить совместимость даже со старыми версиями \texttt{Android}. Для унификации подхода было принято решени выделить интерфейс \texttt{TimeProvider}, а для обратной совместимости - использовать механизм \texttt{coreLibraryDesugaring}, доступный в \texttt{Gradle Api}.

\begin{algorithm}[!h]
\caption{Исходный код \texttt{TimeProvider}}
\begin{lstlisting}
interface TimeProvider {
   fun now(): LocalDateTime
   fun today(): LocalDateTime
}
\end{lstlisting}
\end{algorithm}

\subsection{Модуль для работы с SharedPreferences}
SharedPreferences является механизмом сохранения данных на файловую систему через \texttt{XML} файлы в формате ключ-значение. Так как SharedPrefences относится к \texttt{Android API}, то данный механизм также нужно закрыть своими внутренними интерфейсами, чтобы предоставить возможность писать юнит-тесты, убрав зависимость на \texttt{Android SDK}. Было принято решение выделить интерфейсы:
\begin{enumerate}
    \item \texttt{Preference<T>} - для доступа к конкретному ключу файла.
    \item \texttt{PreferencesFactory} - для получения \texttt{Preference} по конкретному типу и ключу.
\end{enumerate}

\begin{algorithm}[!h]
\caption{Исходный код \texttt{Preference}}
\begin{lstlisting}
interface Preference<T> {
    fun get(): T
    fun put(value: T)
    fun putForce(value: T)
    fun hasValue(): Boolean
    fun clear()
}
\end{lstlisting}
\end{algorithm}


\begin{algorithm}[!h]
\caption{Исходный код \texttt{PreferencesFactory}}
\begin{lstlisting}
interface PreferencesFactory {
    fun intPreference(key: String): Preference<Int>
    fun stringPreference(key: String): Preference<String>
    fun booleanPreference(key: String): Preference<Boolean>
    fun clearAll()
}
\end{lstlisting}
\end{algorithm}

\subsection{Модуль для централизованного управления конфигурацией приложения}
Конфигурационные параметры приложения, такие как режим отладки, версия сборки и флаги функциональности, вынесены в отдельный модуль \texttt{configuration}. Это позволяет унифицировать доступ к параметрам и исключает их дублирование в различных частях кода. Реализация интерфейса \texttt{AppConfiguration} должна быть внесена в граф зависимостей приложения при старте приложения.

\begin{algorithm}[!h]
\caption{Исходный код \texttt{AppConfiguration}}
\begin{lstlisting}
interface AppConfiguration {
    val isDebug: Boolean
    val appVersion: String
}
\end{lstlisting}
\end{algorithm}

\section{Проектирование архитектурного подхода к управлению состоянием приложения}\label{arch:mvi}
В соответствие с описанием выбранного архитектурного подхода, описанного в главе \ref{mvi}, было принято решение выделить следующие интерфейсы:
\begin{enumerate}
    \item \texttt{VisifyState} - маркерный интерфейс, определяющий состояние конкретной функциональности.
    \item \texttt{VisifyIntent} - маркерный интерфейс, отвечающий за репрезентацию пользовательского взаимодействия.
    \item \texttt{VisifyEffect} - маркерный интерфейс, определяющий одноразовые события (например навигацию или всплывающие сообщения).
    \item \texttt{VisifyViewModel} - интерфейс, предоставляющий возможность \texttt{UI} объектам подписаться на изменения состояния, а также сообщить о намерениях пользователя.
    \item \texttt{VisifyReducer} - интерфейс, инкапсулирующий логику изменение состояния в соответствие с намерением пользователя.
\end{enumerate}

 Идея использования паттерна \texttt{Reducer} взята из общепринятых подходов к разработке, используемых во фреймворке \texttt{Redux}.

\begin{algorithm}[!h]
\caption{Исходный код \texttt{VisifyViewModel}}
\begin{lstlisting}
interface VisifyViewModel<S, E, I>  where
    S : VisifyState,
    E : VisifyEffect,
    I : VisifyIntent 
{
    val state: StateFlow<S>
    val effect: SharedFlow<E>
    fun handleIntent(intent: I)
}
\end{lstlisting}
\end{algorithm}

\begin{algorithm}[!h]
\caption{Исходный код \texttt{VisifyReducer}}
\begin{lstlisting}
interface VisifyReducer<S, I>  where
    S : VisifyState,
    I : VisifyIntent 
{
    fun reduce(state: S, intent: I): S
}
\end{lstlisting}
\end{algorithm}

\section{Проектирование утилитарных модулей}
С учетом ограничений, описанных в главе \ref{androidsdk}, в частности в пункте \ref{sdkcomplex}, было принято решение спроектировать группу модулей инкапсулирующих логику взаимодействия с геолокацией, уведомлениями и кэшированием.
\subsection{Модуль для работы с геолокацией}\label{location}
Для получения данных о локации пользователя недостаточно просто вызвать соответствующий метод — это комплексный сценарий, требующий выполнения нескольких условий. Во-первых, необходимо проверить и запросить разрешения на доступ к геолокации, так как без них система просто заблокирует выполнение запроса. Во-вторых, управление запросами должно иметь доступ до \texttt{ActivityResultCaller}, что при небрежном использовании в слое бизнес-логики может вызывать утечки памяти. В-третьих, получение самих данных о местоположении в Android до сих пор завязано на устаревший механизм \texttt{Callback}, что усложняет интеграцию с современными архитектурными подходами, такими как \texttt{Flow} или \texttt{suspend-функции} в \texttt{Kotlin}. Для решения этих проблем было принято решение выделить интерфейсы \texttt{LocationHelper} и \texttt{LocationHelperFactory}

\begin{algorithm}[!h]
\caption{Исходный код \texttt{LocationHelper}}
\begin{lstlisting}
interface LocationHelper {
    fun hasPermissions(): Boolean
    suspend fun requireLocation(): Location?
    suspend fun ensurePermissions()
}
\end{lstlisting}
\end{algorithm}

\begin{algorithm}[!h]
\caption{Исходный код \texttt{LocationHelperFactory}}
\begin{lstlisting}
interface LocationHelperFactory {
    fun create(
        context: Context,
        caller: ActivityResultCaller
    ): LocationHelper
}
\end{lstlisting}
\end{algorithm}

\subsection{Модуль для работы с уведомлениями}
Для получения \texttt{Push-уведомлений} с сервера и отображения уведомлений в панели системы необходимо учитывать несколько факторов, которые зависят не только от \texttt{AndroidSDK}, а ещё и от экосистемы конкретного устройства.
Во-первых, отправка уведомлений требует правильной настройки \texttt{NotificationChannel}, определяющий базовые параметры оторбажения - иконка уведомления, приоритет, звук, вибрацию и прочие настройки. Без этого механизма на устройствах с версией операционной системы выше 8.0 попросту не будут отображаться. Во-вторых, механизмы получения \texttt{Push-уведомлений} зависят от производителя устройства. На большинстве устройств используется \texttt{Google Mobile Services} и \texttt{Firebase Cloud Messaging}, но на устройствах, где \texttt{GMS} недоступен, нужно использовать \texttt{Huawei Mobile Services} или \texttt{RuStore Push} для российского сегмента. Для решения этих проблем было принято решение выделить интерфейсы \texttt{NotificationHelper} и \texttt{PushManager}.

\begin{algorithm}[!h]
\caption{Исходный код \texttt{NotificationHelper}}
\begin{lstlisting}
interface NotificationHelper {
    fun areNotificationsEnabled(): Boolean
    fun showPushNotification(notification: VisifyNotification)
}
\end{lstlisting}
\end{algorithm}

\begin{algorithm}[!h]
\caption{Исходный код \texttt{PushManager}}
\begin{lstlisting}
interface PushManager {
    fun areServicesAvailable(context: Context): Boolean
    suspend fun makeServicesAvailable(activity: Activity): Boolean
    suspend fun registerDeviceToken(): String
    fun unregisterDeviceToken()
}
\end{lstlisting}
\end{algorithm}

Вспомогательным интерфейсом, для фильтрации показа уведомлений на экранах, которые требуют игнорирования их отображения (например экраны чатов) - был добавлены интерфейсы \texttt{NotificationShowingProxy} и \texttt{NotificationFilter}.

\begin{algorithm}[!h]
\caption{Исходный код \texttt{NotificationShowingProxy}}
\begin{lstlisting}
interface NotificationShowingProxy {
    fun clearFilter()
    fun setShowingFilter(filter: NotificationFilter)
    fun sendNotification(notification: VisifyNotification)
}
\end{lstlisting}
\end{algorithm}

\begin{algorithm}[!h]
\caption{Исходный код \texttt{NotificationFilter}}
\begin{lstlisting}
fun interface NotificationFilter {
    fun filter(notification: VisifyNotification): Boolean
}
\end{lstlisting}
\end{algorithm}

\subsection{Модуль для работы с кэшированием}
Подход \texttt{Offline-First} на данный момент стал стандартом для проектирования приложений, так как он позволяет обеспечить удобный пользовательский опыт при нестабильном интернет-соединении. При этом для рабоыт с подобной системой важно, чтобы механизм кэширования был достаточно гибким - должен поддерживать разные источники данных (например, локальную базу, файловое хранилище, \texttt{SharedPreferences}) и учитывать параметры хранения - стратегию обновления данных, а также приоритет источников. Для достижения описанных требований были выделены следующие интерфейсы:
\begin{enumerate}
    \item \texttt{Parameters} - маркерный интерфейс для определения конкретных параметров к кэшу или удаленному источнику данных.
    \item \texttt{RepositoryProperty} - представляет из себя обертку для репозиториев данных, предоставляя доступ для загрузки данных, обновления кэша и его очистки.
    \item \texttt{CachedSource} - представляет из себя обертку для управления локальными данными.
    \item \texttt{RemoteSource} - представляет из себя обертку для управления удаленными данными.
\end{enumerate}

\begin{algorithm}[!h]
\caption{Исходный код \texttt{RepositoryProperty}}
\begin{lstlisting}
interface RepositoryProperty<T, Param> where Param : Parameters {
    suspend fun load(
        forceUpdate: Boolean,
        parameters: Param,
    ): T
    suspend fun updateCache(parameters: Param, cached: T)
    suspend fun clearCache()
}
\end{lstlisting}
\end{algorithm}

\begin{algorithm}[!h]
\caption{Исходный код \texttt{CachedSource}}
\begin{lstlisting}
interface CachedSource<T, Param> where Param : Parameters {
    suspend fun get(param: Param): T?
    suspend fun put(value: T, param: Param)
    suspend fun clear()
}
\end{lstlisting}
\end{algorithm}

\begin{algorithm}[!h]
\caption{Исходный код \texttt{RemoteSource}}
\begin{lstlisting}
fun interface RemoteSource<T, Param> where Param : Parameters {
    suspend fun load(parameters: Param): T
}
\end{lstlisting}
\end{algorithm}

Для обеспечения корректной работы с коллекциями данных, были созданы расширенные интерфейсы, позволяющие обновлять отдельные элементы в этих коллекциях.
\begin{algorithm}[!h]
\caption{Исходный код расширенных интерфейсов}
\begin{lstlisting}
interface RepositoryCollectionProperty<T, Param : Parameters>
    : RepositoryProperty<CollectionResponse<T>, Param>
{
    suspend fun updateSingleEntry(updater: (T) -> T)
}

interface CollectionCachedSource<T, Param: Parameters> :
    CachedSource<CollectionResponse<T>, Param> {
    suspend fun updateSingleEntry(updater: (T) -> T)
}
\end{lstlisting}
\end{algorithm}

\section{Проектирование модулей пользовательского интерфейса и навигации}

\subsection{Модуль компонентов пользовательского интерфейса}
Модуль \texttt{:ui:kit} служит центральным хранилищем базовых компонентов, используемых для построения пользовательского интерфейса. В него входят стили, цветовые схемы, шрифты и другие элементы, которые помогают поддерживать единый визуальный облик всего приложения. Благодаря этому достигается консистентность интерфейса на всех экранах, а управление стилем становится более удобным и централизованным.

Использование общего набора тем и компонентов не только повышает качество UI, но и сокращает дублирование кода, упрощая поддержку и развитие приложения. В \texttt{:ui:kit} можно выделить ключевые элементы, такие как кнопки, текстовые поля, карточки и списки — они многократно используются в разных частях проекта и обеспечивают единообразие пользовательского опыта.

\subsection{Модуль для работы с навигацией в приложении}
Эффективная навигация в приложении — это не просто переходы между экранами, а структурированный и предсказуемый процесс, который должен учитывать особенности разных UI-фреймворков. Для этого необходимо создать абстракции, позволяющие единообразно представлять экраны и управлять маршрутами, независимо от того, используется ли в проекте \texttt{Fragment-навигатор} или \texttt{Jetpack Compose Navigation}.
Такой подход помогает добиться гибкости в архитектуре и снижает зависимость от конкретной реализации. Кроме того, важно предусмотреть механизм управления стеком экранов, чтобы разработчики могли программно изменять историю переходов, например, очищать стек при логине или открывать определённые экраны по глубоким ссылкам без необходимости хранить избыточную логику в каждом модуле.
Модуль навигации должен предоставлять единый интерфейс для работы с маршрутами, позволяя кодовой базе оставаться чистой и понятной, независимо от используемых технологий. Именно для этого были выделены следующие абстракции:
\begin{enumerate}
    \item \texttt{VisifyScreen} - инкапсулирует информацию об экране.
    \item \texttt{VisifyRouter} - предоставляет методы для реализации переходов между экранами.
\end{enumerate}

\begin{algorithm}[!h]
\caption{Исходный код \texttt{VisifyScreen}}
\begin{lstlisting}
abstract class VisifyScreen {
    @AnimRes
    @AnimatorRes
    var animEnter: Int? = null

    @AnimRes
    @AnimatorRes
    var animOut: Int? = null

    @AnimRes
    @AnimatorRes
    var popAnimEnter: Int? = null

    @AnimRes
    @AnimatorRes
    var popAnimOut: Int? = null
}
\end{lstlisting}
\end{algorithm}

\begin{algorithm}[!h]
\caption{Исходный код \texttt{VisifyRouter}}
\begin{lstlisting}
interface VisifyRouter {
    suspend fun navigateTo(screen: VisifyScreen)
    suspend fun navigateTo(
        screen: VisifyScreen,
        animation: VisifyNavAnimation
    )
    suspend fun newRootScreen(screen: VisifyScreen)
    suspend fun replaceScreen(screen: VisifyScreen)
    suspend fun backTo(screen: VisifyScreen?)
    suspend fun backToLastNotAuth()
    suspend fun newChain(vararg screens: VisifyScreen)
    suspend fun newRootChain(vararg screens: VisifyScreen)
    suspend fun finishChain()
    suspend fun exit()
}
\end{lstlisting}
\end{algorithm}

\section{Графическое представление спроектированной архитектуры}
TODO()

%% Chapter 4
\chapter{Реализация спроектированных модулей}
\section{Реализация механизма внедрения зависимостей}
Для реализации документации, описанной в главе \ref{di}, было принято решение предоставить другим разработчикам файл, оформленный с помощью \texttt{Markdown} разметки в корне проекта. Таким образом, открывая проект пользователь увидит актуальную документ, объясняющий принципы и подходы, используемые в данном продукте, связанные с внедрением зависимостей.
В соответствии с блоками документации, спроектированными в главе \ref{di} приведены соответствующие реализации:
\begin{enumerate}
    \item Рисунок \ref{di-md-intro} для \ref{di}\ref{di:first}
    \item Рисунок \ref{di-md-second} для \ref{di}\ref{di:second}
    \item Рисунок \ref{di-md-third} для \ref{di}\ref{di:third}
    \item Рисунок \ref{di-md-fourth} для \ref{di}\ref{di:fourth}
    \item Рисунок \ref{di-md-fifth} для \ref{di}\ref{di:fifth}
    \item Рисунок \ref{di-md-sixth} для \ref{di}\ref{di:sixth}
\end{enumerate}

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{di-md-intro.png}
    \caption{Блок \textit{Введение}}
    \label{di-md-intro}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{di-md-second.png}
    \caption{Блок \textit{Основные принципы работы с Hilt}}
    \label{di-md-second}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{di-md-third.png}
    \caption{Блок \textit{Как структурировать зависимости}}
    \label{di-md-third}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{di-md-fourth.png}
    \caption{Блок \textit{Примеры кода}}
    \label{di-md-fourth}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{di-md-fifth.png}
    \caption{Блок \textit{Стандартные ошибки и их решения}}
    \label{di-md-fifth}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{di-md-sixth.png}
    \caption{Блок \textit{Рекомендации по тестированию}}
    \label{di-md-sixth}
\end{figure}

\break
\section{Реализация сетевых модулей}
\subsection{Реализация модуля \texttt{:net:http:impl}}
Основная задача данного модуля - предоставить приложению доступ до корректно настроенного \texttt{OkHttpClient} для сетевого взаимодействия. Для базовых сценариев с \texttt{HTTP} запросами предлагается реализация \texttt{DefaultHttpClientProvider}. Для обеспечения аутентификации сетевых запросов как зависимость в данный класс предоставляется реализация интерефейса \texttt{okhttp3.Authenticator}, представленная в листинге \ref{net:authenticator}. В свою очередь, наш аутентификатор использует реализацию интерфейса \texttt{AuthServiceProxy} для обновления протухших токенов. В случае неуспешного обновления, сервис проверяет необходимость аутентификации для конкретного запроса. Если таковая требуется, то сообщает приложению, что необходимо навигировать пользователя к экрану авторизации. Для проставления необходимых аутетификационных заголовков в \texttt{DefaultHttpProvider} передается соответствующий перехватчик запросов, модифицирующий изначальный \textit{HTTP} запрос и добавляющий необходимые заголовки. Реализация представлена в листинге \ref{net:interceptor}.
\begin{lstlisting}[caption={Исходный код \texttt{DefaultHttpClientProvider}}]
class DefaultHttpClientProvider(
    private val interceptorCollector: InterceptorCollector,
    private val authenticator: Authenticator,
    private val verifierManager: LocalhostHostnameVerifierManager,
) : HttpClientProvider {
    override val client: OkHttpClient by lazy { createClient() }

    private fun createClient(): OkHttpClient {
        return OkHttpClient.Builder()
            .apply {
                interceptorCollector.provideInterceptors()
                    .forEach { addInterceptor(it) }
            }
            .authenticator(authenticator)
            .connectTimeout(Duration.ofMinutes(1))
            .readTimeout(Duration.ofMinutes(1))
            .writeTimeout(Duration.ofMinutes(1))
            .apply {
                if (verifierManager.isEnable()) {
                    hostnameVerifier(verifierManager)
                }
            }
            .build()
    }
}
\end{lstlisting}

\begin{lstlisting}[caption={Исходный код \texttt{VisifyAuthenticator}}, label={net:authenticator}]
internal class VisifyAuthenticator(
    private val authServiceProxy: AuthServiceProxy,
    private val tokenManager: AuthTokenManager
) : Authenticator {
    override fun authenticate(route: Route?, response: Response): Request? = when {
        checkDropNewRequest(response) -> null
        else -> runBlocking {
            val isTokenUpdateSucceed = authServiceProxy.updateTokens(response.request)
            if (isTokenUpdateSucceed.not())
                return@runBlocking null
            val access = tokenManager.access()
            val refresh = tokenManager.refresh()
            response.request.newBuilder()
                .header(VisifyHeaders.ACCESS_HEADER, access.toBearer())
                .header(VisifyHeaders.REFRESH_HEADER, refresh.toBearer())
                .build()
        }
    }

    private fun checkDropNewRequest(response: Response): Boolean {
        // it is first request so ---> false
        if (response.priorResponse == null) return false
        return response.retryCount >= RETRY_CONSTRAINT
    }

    companion object {
        private const val RETRY_CONSTRAINT = 1
    }
}
\end{lstlisting}

\begin{lstlisting}[caption={Исходный код реализации интерфейса \texttt{AuthServiceProxy}}, label={net:authenticator}]
class AuthServiceProxyImpl(
    dispatchers: CoroutineDispatchers,
    private val authRefreshService: AuthRefreshService,
    private val tokenManager: AuthTokenManager,
    private val appAuthListener: AppAuthListener,
    private val forceAuthFilter: ForceAuthFilter,
) : AuthServiceProxy {

    private val scope = CoroutineScope(dispatchers.io) + Job()

    @Volatile
    private var actualJob: Deferred<Boolean>? = null
    private val isJobRunning = AtomicBoolean(false)

    /**
     * @return is update token succeed
     */
    suspend fun updateTokens(request: Request): Boolean {
        if (isJobRunning.compareAndSet(false, true)) {
            actualJob = scope.async { updateTokensInternal(request) }
        }
        return actualJob?.await() ?: false
    }

    private suspend fun updateTokensInternal(request: Request): Boolean {
        val currentAccess = tokenManager.access()
        val currentRefresh = tokenManager.refresh()
        val result = runCatching {
            authRefreshService.refresh(
                currentAccess.toBearer(),
                currentRefresh.toBearer()
            )
        }.onFailure { exc ->
            when {
                exc.isAuthException -> {
                    if (forceAuthFilter.isNeedToAuth(request)) {
                        appAuthListener.onAuthFailed()
                    }
                }
            }
        }.onSuccess { response ->
            tokenManager.setAccess(response.accessToken)
            tokenManager.setRefresh(response.refreshToken)
        }
        actualJob = null
        isJobRunning.set(false)
        return result.isSuccess
    }
}
\end{lstlisting}
\begin{lstlisting}[caption={Исходный код \texttt{AuthenticatorInterceptor}}, label={net:interceptor}]
class AuthenticatorInterceptor(
    private val tokenManager: AuthTokenManager
): Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val accessToken = tokenManager.access()
        val refreshToken = tokenManager.refresh()
        if (accessToken.isBlank() || refreshToken.isBlank()) {
            return chain.proceed(chain.request())
        }
        val request = chain.request().newBuilder()
            .header(VisifyHeaders.ACCESS_HEADER, accessToken.toBearer())
            .header(VisifyHeaders.REFRESH_HEADER, refreshToken.toBearer())
            .build()
        return chain.proceed(request)
    }
}
\end{lstlisting}

\subsection{Реализация модуля \texttt{:net:http:sse:impl}}
Главным классом данного модуля является реализация интерфейса \texttt{SseConnectionEngine}, которая отвечает за запуск и управление соединением для получения \texttt{SSE} событий от сервера. При наличии некоторого количества одинаковых ошибок, не связанных с ограничениями на время соединения, механизм перестает пытаться восстановиться и ждёт явных указаний для восстонавления соединения. Все полученые события отдаются в предоставленную извне реализацию интерфейса \texttt{SseEventHandler}, а реализация \texttt{SseConnectionRunnable} инкапсулирует непосредственно логику подключения к серверу.

\begin{lstlisting}[caption={Исходный код \texttt{SseConnectionEngineImpl}}]
class SseConnectionEngineImpl @Inject constructor(
    private val service: ConnectionService,
    private val eventBus: EventBus,
    private val eventHandler: SseEventHandler,
): ServerConnectionEngine {

    private val exceptionFilter: (Throwable) -> Boolean = { it is SocketTimeoutException }

    private val executor = Executors.newFixedThreadPool(THREAD_COUNT)

    @Volatile
    private var _isRunning: Boolean = false

    private var authListenerFuture: Future<*>? = null
    private var networkListenerFuture: Future<*>? = null

    private var actualRunner: SseConnectionRunnable? = null

    private val failuresCollection = ConcurrentHashMap<Class<*>, Int>()

    override val isRunning: Boolean
        get() = _isRunning || actualRunner?.isRunning == true

    override fun start() {
        Log.i(TAG, "Trying to startup SSE engine")

        if (isRunning) {
            Log.i(TAG, "SSE Engine is already started, nothing to do")
            return
        }

        if (_isRunning.not()) {
            synchronized(this) {
                if (_isRunning) return
                _isRunning = true
            }
        }

        startConnection()
        observeSideEffects()
    }


    private fun observeSideEffects() {
        if (authListenerFuture?.isDone == true) {
            authListenerFuture = executor.submit {
                runBlocking {
                    eventBus.events
                        .filterIsInstance<OnAuthSucceed>()
                        .distinctUntilChanged { _, _ -> false }
                        .subscribe {
                            startConnection()
                        }
                }
            }
        }
        if (networkListenerFuture?.isDone == true) {
            networkListenerFuture = executor.submit {
                runBlocking {
                    eventBus.events
                        .filterIsInstance<NetworkStateEvent>()
                        .filter { it.isNetworkAvailable }
                        .distinctUntilChanged()
                        .subscribe {
                            if (actualRunner?.isRunning == false) {
                                startConnection()
                            }
                        }
                }
            }
        }
    }

    private fun startConnection() {
        Log.d(TAG, "Starting connection to server | runner = ${actualRunner?.isRunning}")
        actualRunner?.cancel()
        actualRunner = SseConnectionRunnableImpl(
            service = service,
            onEvent = ::handleConnectionEvent,
            onException = ::handleException,
            onStop = { gracefully ->
                Log.d(TAG, "SSE Connection has stopped; gracefully = $gracefully")
                failuresCollection.clear()
                if (gracefully) {
                    startConnection()
                }
            }
        )
        executor.submit(actualRunner)
    }

    override fun stop() {
        Log.i(TAG, "SSE Engine stopping; failures = [${failuresCollection.size}] runner = [${actualRunner?.isRunning}]")
        failuresCollection.clear()
        actualRunner?.cancel()
        actualRunner = null
        _isRunning = false
    }

    private fun handleConnectionEvent(payload: String) {
        Log.i(TAG, "SSE handled event = $payload")
        eventHandler.handleEvent(payload = payload)
    }

    private fun handleException(exc: Throwable) {
        Log.e(TAG, "SSE Handled exception", exc)
        if (exceptionFilter(exc)) {
            Log.i(TAG, "Exception passed filter | restarting")
            startConnection()
            return
        }
        val failures = failuresCollection.getOrPut(exc::class.java) { 0 } + 1
        Log.e(TAG, "SSE Failed times = $failures")
        failuresCollection[exc::class.java] = failures
        if (failures >= FAILURES_THRESHOLD) {
            stop()
            return
        }
        startConnection()
    }

    companion object {
        private const val FAILURES_THRESHOLD = 5
        private const val THREAD_COUNT = 4
        private const val TAG = "SseConnectionEngine"
    }
}
\end{lstlisting}

\begin{lstlisting}[caption={Исходный код \texttt{SseConnectionRunnableImpl}}]
internal class SseConnectionRunnableImpl(
    private val service: ConnectionService,
    private val onEvent: (String) -> Unit,
    private val onException: (Throwable) -> Unit,
    private val onStop: (Boolean) -> Unit
) : SseConnectionRunnable {

    @Volatile
    private var _isRunning: Boolean = true

    private var request: SseCall? = null
    private var reader: BufferedReader? = null

    override val isRunning: Boolean
        get() = _isRunning


    override fun run() {
        runCatching {
            request = service.connect()
            request?.let { call ->
                val response = call.execute()
                if (response.isSuccessful.not()) throw HttpException(response)
                reader = response.body()?.byteStream()?.bufferedReader()
                    ?: throw IllegalStateException()

                while (Thread.interrupted().not() && isRunning) {
                    val input = reader?.readLine() ?: continue
                    if (input.isBlank()) continue
                    when {
                        input.startsWith(DATA_TAG) -> processData(input.content(DATA_TAG))
                        input.startsWith(ID_TAG) -> processId(input.content(ID_TAG))
                        input.startsWith(EVENT_TAG) -> processEvent(input.content(EVENT_TAG))
                    }
                }
            }
        }
            .fold(
                onSuccess = {
                    request?.cancel()
                    reader?.closeQuietly()
                    onStop(isRunning)
                },
                onFailure = {
                    request?.cancel()
                    reader?.closeQuietly()
                    onException(it)
                }
            )
    }

    private fun processData(data: String) = onEvent(data)
    private fun processId(id: String) = Unit
    private fun processEvent(event: String) = Unit

    private fun String.content(tag: String) = substring(tag.length)

    override fun cancel() {
        _isRunning = false
    }

    companion object {
        private const val ID_TAG = "id:"
        private const val EVENT_TAG = "event:"
        private const val DATA_TAG = "data:"
    }
}
\end{lstlisting}

\section{Реализация инфраструктурных модулей}
\subsection{Реализация модуля \texttt{ktx}}
Внутри данного модуля должно быть создано две отдельные директории - \texttt{main} и \texttt{testFixture}. В \texttt{main} должна быть расположена реализация, которая будет использоваться в основном окружении, а в \texttt{testFixture} - в тестовом окружении соответственно.
\begin{algorithm}[!h]
\caption{Исходный код для \texttt{main}}
\begin{lstlisting}
class CoroutineDispatchersImpl : CoroutineDispatchers {
   override val main: CoroutineDispatcher = Dispatchers.Main
   override val io: CoroutineDispatcher = Dispatchers.IO
   override val default: CoroutineDispatcher = Dispatchers.Default
}
\end{lstlisting}
\end{algorithm}

\begin{algorithm}[!h]
\caption{Исходный код для \texttt{testFixture}}
\begin{lstlisting}
class CoroutineDispatchersImpl : CoroutineDispatchers {
   override val main: CoroutineDispatcher = Dispatchers.Unconfined
   override val io: CoroutineDispatcher = Dispatchers.Unconfined
   override val default: CoroutineDispatcher = Dispatchers.Unconfined
}
\end{lstlisting}
\end{algorithm}

\subsection{Реализация модуля \texttt{buildSrc}}
Ключевые компоненты данного модуля:
\begin{enumerate}
    \item \texttt{androidApp} — утилита для быстрой настройки корневого модуляприложений, включающая в себя стандартные параметры, такие как compileSdk, defaultConfig и общие плагины.
    \item \texttt{androidModule} - абстракция, предназначенная для унифицированной настройки фича-модулей, что позволяет избежать разрозненных конфигураций.
    \item \texttt{androidCore, androidApi, androidImpl} - удобные обертки, задача которых передать в \texttt{androidModule} соответствующий тип объявленного модуля.
    \item \texttt{VisifyDependencyScope} - позволяет управлять и валидировать зависимости, которые подключаются к заявленному модулю. Валидация достигается за счет добавления в \texttt{extraProperties} при конфигурации тип конфигурируемого модуля.
\end{enumerate}
Реализация \texttt{androidApp} функции представляет собой расширение для \texttt{org.gradle.api.Project} автоматически подключаая необходимые плагины, задавая основные параметры сборки (\texttt{package}, версии, поддержку \texttt{Compose}), а также настраивает подпись приложения, варианты сборки и опции компиляции. В свою очередь, \texttt{androidModule} функция реализует похожий механизм настройки, с отличием, что происходит конфигурация \texttt{LibraryExtension}, вместо \texttt{BaseAppModuleExtension}.


\begin{lstlisting}[caption={Исходный код \texttt{androidApp}}]
fun Project.androidApp(
    pkg: String,
    code: Int,
    version: String,
    useCompose: Boolean,
    signings: List<Signing>,
    variants: List<Variant>,
    deps: VisifyDependencyScope.() -> Unit,
    placeholders: Map<String, String> = emptyMap(),
    plugins: List<String> = emptyList(),
    configure: Project.() -> Unit = {  }
) {

    apply(plugin = "com.android.application")
    apply(plugin = "org.jetbrains.kotlin.android")
    apply(plugin = "io.gitlab.arturbosch.detekt")
    plugins.forEach { id ->
        apply(plugin = id)
    }

    configure()

    configure<BaseAppModuleExtension> {
        namespace = pkg
        compileSdk = Config.compileSdk

        buildFeatures {
            buildConfig = true
            compose = useCompose
        }

        defaultConfig {
            applicationId = pkg
            minSdk = Config.minSdk
            targetSdk = Config.targetSdk

            versionCode = code
            versionName = version

            multiDexEnabled = true

            vectorDrawables { useSupportLibrary = true }

            placeholders.forEach { (key, value) ->
                manifestPlaceholders[key] = value
            }

            testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        }

        signingConfigs {
            signings.forEach { signing ->
                maybeCreate(signing.type).let { config ->
                    config.storeFile = File(tools, signing.storeFilename)
                    config.keyAlias = signing.alias
                    config.keyPassword = signing.password
                }
            }
        }

        buildTypes {
            variants.forEach { variant ->
                maybeCreate(variant.name).let { type ->
                    type.isMinifyEnabled = variant.isMinifyEnabled
                    type.proguardFiles.addAll(
                        listOf(
                            optimizeFile,
                            file(variant.projectRelativeProguard)
                        ),
                    )
                }
            }
        }

        compileOptions {
            isCoreLibraryDesugaringEnabled = true
            sourceCompatibility = Config.sourceCompat
            targetCompatibility = Config.targetCompat
        }

        composeOptions {
            kotlinCompilerExtensionVersion = Config.composeKotlinCompilerExtensionVersion
        }

        (this as ExtensionAware).extensions.configure<KotlinJvmOptions>("kotlinOptions") {
            jvmTarget = Config.kotlinJvmTarget.target
        }

        packaging {
            resources {
                excludes += "/META-INF/{AL2.0,LGPL2.1}"
            }
        }
    }

    dependencies {
        VisifyDependencyScope(this).apply(deps)
    }

    detekt {
        source = files(projectDir)
        config = files("${project.rootDir}/config/detekt/detekt.yml")
        parallel = true
    }
}
\end{lstlisting}
\begin{lstlisting}[caption={Исходный код \texttt{androidModule}},label={buildSrc:androidModule}]
fun Project.androidModule(
    pkg: String,
    type: ModuleType,
    useCompose: Boolean,
    desugaringEnabled: Boolean = false,
    plugins: List<String> = emptyList(),
    deps: VisifyDependencyScope.() -> Unit,
) {
    apply(plugin = "com.android.library")
    apply(plugin = "org.jetbrains.kotlin.android")
    plugins.forEach { id ->
        apply(plugin = id)
    }
    extensions.extraProperties["visify-module-type"] = type
    configure<LibraryExtension> {
        namespace = pkg
        compileSdk = Config.compileSdk

        buildFeatures {
            buildConfig = true
            compose = useCompose
        }

        defaultConfig {
            minSdk = Config.minSdk
            testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        }

        composeOptions {
            kotlinCompilerExtensionVersion = Config.composeKotlinCompilerExtensionVersion
        }

        compileOptions {
            isCoreLibraryDesugaringEnabled = desugaringEnabled
            sourceCompatibility = Config.sourceCompat
            targetCompatibility = Config.targetCompat
        }

        (this as ExtensionAware).extensions.configure<KotlinJvmOptions>("kotlinOptions") {
            jvmTarget = Config.kotlinJvmTarget.target
        }
    }
    dependencies {
        VisifyDependencyScope(this, type).apply(deps)
    }
}
\end{lstlisting}

\begin{algorithm}[!h]
\caption{Исходный код для \texttt{VisifyDependencyScope}}
\begin{lstlisting}
enum class ModuleType { Core, Api, Impl }

class VisifyDependencyScope(
    private val delegate: DependencyHandlerScope,
    private val ownerType: ModuleType
) {

    constructor(delegate: DependencyHandlerScope): this(
        delegate,
        ModuleType.Impl
    )
    
    fun api(dependency: Project) {
        validateDependency(dependency, ModuleType.Api)
        delegate.add("api", dependency)
    }

    fun impl(dependency: Project) {
        validateDependency(dependency, ModuleType.Impl)
        delegate.add("implementation", dependency)
    }

    private fun validateDependency(dependency: Project, type: ModuleType) {
        val otherType = dependency.extraProperties["visify-module-type"]
        val validTypes = when (ownerType) {
            ModuleType.Api -> listOf(ModuleType.Api)
            ModuleType.Impl -> listOf(ModuleType.Api, ModuleType.Impl, ModuleType.Core)
            ModuleType.Core -> listOf(ModuleType.Api, ModuleType.Core)
        }

        if (validTypes.none { valid -> valid == ownerType }) {
            throw IllegalArgumentException("Module ${dependency.path} cannot be added as $type dependency")
        }
    }
}
\end{lstlisting}
\end{algorithm}

\subsection{Реализация модуля \texttt{time}}
В данном модуле находится реализация интерфейса \texttt{TimeProvider}, использующий \texttt{LocalDateTime}, который становится доступным при проставленном параметре \texttt{desugaringEnabled} при объявлении данного модуля через функцию \texttt{androidModule}, описанную в листинге \ref{buildSrc:androidModule}.
\begin{algorithm}[!h]
\caption{Исходный код для \texttt{TimeProviderImpl}}
\begin{lstlisting}
class TimeProviderImpl @Inject constructor(): TimeProvider {
   override fun now(): LocalDateTime = LocalDateTime.now()
   override fun today(): LocalDateTime {
       return now().withMidnight()
   }
   override fun todayDate(): LocalDate = LocalDate.now()
}
\end{lstlisting}
\end{algorithm}

\subsection{Реализация модуля \texttt{preferences}}
Так как у интерфейса \texttt{SharedPreferences} нет шаблонных функций, то придется отдельно прописать реализации на каждый необходимый тип значений - строк, булевых флагов и целых чисел. Для каждого типа это соответственно методы \texttt{putInt}, \texttt{putString} и \texttt{putBoolean}. \texttt{IntPreference}, \texttt{StringPreference} и \texttt{BooleanPreference} в следствие этого имеют практически одинаковую реализацию, поэтому будет приведен только исходный код одного из них. Что касается \texttt{PreferenceFactory}, то реализация этого интерфейса просто отвечает за создание реализаций, описанных выше.

\begin{algorithm}[!h]
\caption{Исходный код для \texttt{IntPreference}}
\begin{lstlisting}
class IntPreference(
    private val key: String,
    private val sharedPreferences: SharedPreferences
) : Preference<Int> {
    override fun get(): Int = sharedPreferences.getInt(key, -1)

    override fun hasValue(): Boolean = sharedPreferences.contains(key)

    override fun put(value: Int) = sharedPreferences.edit {
        putInt(key, value)
    }

    override fun putForce(value: Int) = sharedPreferences.edit(commit = true) {
        putInt(key, value)
    }

    override fun clear() = sharedPreferences.edit { remove(key) }
}
\end{lstlisting}
\end{algorithm}

\begin{algorithm}[!h]
\caption{Исходный код для \texttt{PreferenceFactory}}
\begin{lstlisting}
class PreferencesFactoryImpl @Inject constructor(
    @ApplicationContext context: Context
) : PreferencesFactory {

    private val preferencesInternal
        by lazy { context.getSharedPreferences(GLOBAL_PREFS, Context.MODE_PRIVATE) }

    override fun intPreference(key: String): Preference<Int> = Preference.IntPreference(key, preferencesInternal)

    override fun stringPreference(key: String): Preference<String> = Preference.StringPreference(key, preferencesInternal)

    override fun booleanPreference(key: String): Preference<Boolean> = Preference.BooleanPreference(key, preferencesInternal)

    override fun clearAll() { preferencesInternal.edit().clear().commit() }

    companion object {
        private const val GLOBAL_PREFS = "visify.global"
    }
}
\end{lstlisting}
\end{algorithm}

\section{Реализация модуля \texttt{arch}}
Данный модуль отвечает за реализацию архитектурного решения для управления состоянием приложения, описанного в главе \ref{arch:mvi}. Реализация представляет собой базовую \texttt{ViewModel} для архитектуры на основе состояний, эффектов и намерений, обеспечивая управление состоянием через \texttt{StateFlow} и передачу эффектов через \texttt{SharedFlow}. В ней предусмотрены безопасные корутины с обработкой исключений, а также методы для определения начального состояния и обработки пользовательских намерений. 

\begin{lstlisting}[caption={Исходный код \texttt{BaseVisifyViewModel}}]
abstract class BaseVisifyViewModel<S, E, I> : ViewModel()
    where S : VisifyState,
    E : VisifyEffect,
    I : VisifyIntent 
{
    protected val tag by lazy { this::class.java.canonicalName }
    protected val mutableState by lazy { MutableStateFlow(initialState()) }
    protected val visifyState: S
        get() = state.value
    val state: StateFlow<S>
        get() = mutableState.asStateFlow()

    protected val mutableEffect by lazy { MutableSharedFlow<E>() }
    val effect: SharedFlow<E>
        get() = mutableEffect.asSharedFlow()

    private val handler = CoroutineExceptionHandler { _, throwable ->
        onException(throwable)
    }

    protected fun CoroutineScope.launchSafe(
        context: CoroutineContext = EmptyCoroutineContext,
        block: suspend CoroutineScope.() -> Unit,
    ): Job = launch(context + handler, block = block)

    protected fun <T> CoroutineScope.asyncSafe(
        context: CoroutineContext = EmptyCoroutineContext,
        block: suspend CoroutineScope.() -> T,
    ): Deferred<T> = async(context + handler, block = block)

    protected abstract fun initialState(): S

    abstract fun handleIntent(intent: I)

    protected open fun onException(error: Throwable) {
        Log.e(tag, "Exception handled", error)
    }
}
\end{lstlisting}

\section{Реализация утилитарных модулей}
\subsection{Реализация модуля \texttt{location}}
Реализация интерфейса \texttt{LocationHelper} содержит последовательную логику, описанную в главе \ref{location}. Когда пользователю класса необходимо получить текущую геолокацию, то при вызове метода \texttt{requireLocation} сначала проверяется наличие необходимых разрешений. Если разрешения отсутствуют, то запускается системный процесс запроса данных разрешений у пользователя. В свою очередь, выполняемая корутина ожидает результата этого запроса. В случае успеха, через механизм \texttt{FusedLocationProviderClient} отправляется запрос в систему на получение данных о последнем местоположении устройства. При успешном выполнении результат возвращается не как \texttt{android.location.Location} объект, а как свой класс \texttt{visify.location.Location}, чтобы избежать зависимости на \texttt{AndroidSDK} для внешнего пользователя данного модуля.

\begin{lstlisting}[caption={Исходный код \texttt{LocationHelperImpl}}]
class LocationHelperImpl(
    private val context: Context,
    caller: ActivityResultCaller,
) : LocationHelper {

    private val fusedLocationClient: FusedLocationProviderClient by lazy {
        LocationServices.getFusedLocationProviderClient(context)
    }

    private var permissionGranted = CompletableDeferred<Boolean>()

    private val launcher = caller.registerForActivityResult(
        ActivityResultContracts.RequestMultiplePermissions()
    ) { permissions ->
        permissionGranted.complete(
            permissions.entries.any { it.value }
        )
    }

    override fun hasPermissions(): Boolean {
        val fineLocationPermission = ContextCompat.checkSelfPermission(
            context,
            Manifest.permission.ACCESS_FINE_LOCATION
        ) == PackageManager.PERMISSION_GRANTED

        val coarseLocationPermission = ContextCompat.checkSelfPermission(
            context,
            Manifest.permission.ACCESS_COARSE_LOCATION
        ) == PackageManager.PERMISSION_GRANTED

        return fineLocationPermission || coarseLocationPermission
    }

    override suspend fun ensurePermissions() {
        if (hasPermissions().not()) {
            launcher.launch(
                arrayOf(
                    Manifest.permission.ACCESS_FINE_LOCATION,
                    Manifest.permission.ACCESS_COARSE_LOCATION
                )
            )
        } else {
            permissionGranted.complete(true)
        }
    }

    override suspend fun requireLocation(): Location? {
        ensurePermissions()

        return if (permissionGranted.await()) {
            suspendCancellableCoroutine { continuation ->
                runCatching {
                    fusedLocationClient
                        .lastLocation
                        .addOnSuccessListener { location: android.location.Location? ->
                            location?.let {
                                continuation.resume(location.toLocation())
                            } ?: run {
                                continuation.resume(null)
                            }
                        }
                        .addOnFailureListener {
                            continuation.resume(null)
                        }
                }.onFailure {
                    continuation.resume(null)
                }
            }
        } else {
            null
        }
    }

    private fun android.location.Location.toLocation() = Location(
        latitude.toFloat(),
        longitude.toFloat()
    )
}
\end{lstlisting}

\subsection{Реализация модуля \texttt{notifications}}

TODO()

\subsection{Реализация модуля \texttt{repository}}
В спроектированном модуле ключевым классом является реализация интерфейса \texttt{RepositoryProperty}, который обеспечивает корректность загрузки из доступных источников данных. Если по переданным параметрам имеется объект в локальном хранилище, то будет использоваться найденный объект. В противном случае будет использоваться удалённый источник данных. Также имеется возможность принудительно получить данные из удалённого источника, чтобы поддерживать локальное хранилище в актуальном состоянии. Для безопасного получения данных из удаленного источника был создан \texttt{RemoteCallHelper}, позволяющий привести полученную ошибку в более удобную форму для дальнейшей обработки. Что касается \texttt{CachedSource}, то сохранение на диск требует индивидуальной настройки для каждого из объектов, необходимых для кэширования. В свою очередь, модуль предоставляет возможность кэшировать объекты в рамках сессии приложения с помощью \texttt{InMemoryCachedSource}. Для распространённых сценариев были созданы методы, упрощающие создание \texttt{RepositoryProperty}. Пример такого метода приведен в листинге \ref{repository:example}.

\begin{lstlisting}[caption={Исходный код \texttt{RepositoryPropertyImpl}}]
internal class RepositoryPropertyImpl<T, Param>(
    private val remoteSource: RemoteSource<T, Param>,
    private val cachedSource: CachedSource<T, Param>,
) : RepositoryProperty<T, Param> where Param : Parameters {

    override suspend fun load(
        forceUpdate: Boolean,
        parameters: Param,
    ): T {
        if (forceUpdate) {
            return loadInternal(parameters)
        }
        val cached = cachedSource.get(parameters)
        return cached ?: loadInternal(parameters)
    }

    override suspend fun updateCache(parameters: Param, cached: T) {
        cachedSource.put(cached, parameters)
    }

    override suspend fun clearCache() = cachedSource.clear()

    private suspend fun loadInternal(parameters: Param): T {
        val result = remoteSource.load(parameters)
        cachedSource.put(result, parameters)
        return result
    }
}
\end{lstlisting}

\begin{lstlisting}[caption={Исходный код \texttt{RemoteCallHelper}}]
class RemoteCallHelper<T, Params>(
    private val delegate: RemoteSource<T, Params>
) : RemoteSource<T, Params> where Params : Parameters {

    private val gson = Gson()

    override suspend fun load(parameters: Params): T = safeCall { delegate.load(parameters) }

    private suspend fun<T> safeCall(call: suspend () -> T): T {
        val result = runCatching { call() }
            .fold(
                onSuccess = { ResultWrapper.Success(it) },
                onFailure = { wrapError(it) }
            )
        return when (result) {
            is ResultWrapper.Success -> result.value
            is ResultWrapper.Failure -> throw InternalNetworkException(result)
        }
    }

    private fun wrapError(throwable: Throwable): ResultWrapper<Nothing> {
        return when (throwable) {
            is IOException -> ResultWrapper.NetworkError(throwable)
            is HttpException -> {
                val response = throwable.response()?.errorBody()?.source()?.let {
                    val bodyString = it.readString(StandardCharsets.UTF_8)
                    gson.fromJson<ErrorResponse>(
                        JsonReader(StringReader(bodyString)),
                        ErrorResponse::class.java
                    )
                }
                ResultWrapper.Failure(throwable, throwable.code(), response)
            }
            else -> ResultWrapper.Failure(throwable, null, null)
        }
    }
}
\end{lstlisting}

\begin{lstlisting}[caption={Исходный код \texttt{InMemoryCachedSource}}]
class InMemoryCachedSource<T, Params> 
    : CachedSource<T, Params>
    where Params : Parameters 
{

    private val cache: ConcurrentHashMap<Params, T> = ConcurrentHashMap()

    override suspend fun get(param: Params): T? {
        return cache[param]
    }

    override suspend fun put(value: T, param: Params) {
        cache[param] = value
    }

    override suspend fun clear() = cache.clear()
}
\end{lstlisting}

\begin{lstlisting}[caption={Исходный код \texttt{InMemoryCachedSource}}, label={repository:example}]
fun<T, Param : Parameters> repositoryProperty(
    remoteSource: RemoteSource<T, Param>,
    cachedSource: CachedSource<T, Param>
): RepositoryProperty<T, Param> = RepositoryPropertyImpl(
    remoteSource = RemoteCallHelper(remoteSource),
    cachedSource = cachedSource,
)
\end{lstlisting}

\section{Реализация модулей пользовательского интерфейса и навигации}
\subsection{Реализация модулей пользовательского интерфейса}
Модуль \texttt{:ui:kit} в большинстве случаев остается уникальным для каждого проекта, так как \texttt{Material} уже предоставляет все необходимые базовые компоненты, а дизайн внутри компании не пересекается между разными приложениями. Поэтому потребность в универсальном \texttt{:ui:kit} минимальна, и его состав определяется исключительно задачами конкретного продукта. Единственным исключением можно назвать компонент Overlay, который вынесен в отдельный модуль \texttt{:ui:overlay}. Он используется для отображения полноэкранных всплывающих модальных окон и необходим, в первую очередь, для обеспечения единообразного поведения с \texttt{iOS}, которого невозможно добиться стандартным \texttt{ModalBottomSheet} из \texttt{Compose Api}, в частности - полноэкранный режим окна без наложения на панель статуса.

\begin{lstlisting}[caption={Исходный код \texttt{Overlay}}]
class Overlay constructor(
   composeView: View,
   private val onDismissRequest: () -> Unit
) : AbstractComposeView(composeView.context) {

   init {
       setViewTreeLifecycleOwner(composeView.findViewTreeLifecycleOwner())
       setViewTreeViewModelStoreOwner(composeView.findViewTreeViewModelStoreOwner())
       setViewTreeSavedStateRegistryOwner(composeView.findViewTreeSavedStateRegistryOwner())
   }

   private val windowManager =
       composeView.context.getSystemService(Context.WINDOW_SERVICE) as WindowManager

   private val displayWidth: Int
       get() = context.resources.displayMetrics.widthPixels

   private val params = WindowManager.LayoutParams().apply {
       gravity = Gravity.BOTTOM

       type = WindowManager.LayoutParams.TYPE_APPLICATION_PANEL

       width = displayWidth

       height = WindowManager.LayoutParams.MATCH_PARENT

       format = PixelFormat.TRANSLUCENT
       flags = flags and (
               WindowManager.LayoutParams.FLAG_IGNORE_CHEEK_PRESSES or
                       WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
               ).inv()
       flags = flags or WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN
   }

   override var shouldCreateCompositionOnAttachedToWindow: Boolean = false
       private set

   private var content: @Composable () -> Unit by mutableStateOf({})

   @Composable
   override fun Content() {
       content()
   }

   fun setCustomContent(
       parent: CompositionContext? = null,
       content: @Composable () -> Unit
   ) {
       parent?.let { setParentCompositionContext(it) }
       this.content = content
       shouldCreateCompositionOnAttachedToWindow = true
   }

   fun show() {
       windowManager.addView(this, params)
   }

   fun dismiss() {
       setViewTreeLifecycleOwner(null)
       setViewTreeSavedStateRegistryOwner(null)
       windowManager.removeViewImmediate(this)
   }

   override fun dispatchKeyEvent(event: KeyEvent): Boolean {
       if (event.keyCode == KeyEvent.KEYCODE_BACK) {
           if (keyDispatcherState == null) {
               return super.dispatchKeyEvent(event)
           }
           if (event.action == KeyEvent.ACTION_DOWN && event.repeatCount == 0) {
               val state = keyDispatcherState
               state?.startTracking(event, this)
               return true
           } else if (event.action == KeyEvent.ACTION_UP) {
               val state = keyDispatcherState
               if (state != null && state.isTracking(event) && !event.isCanceled) {
                   onDismissRequest()
                   return true
               }
           }
       }
       return super.dispatchKeyEvent(event)
   }
}
\end{lstlisting}

\subsection{Реализация модуля \texttt{navigation}}
Модуль навигации строится вокруг \texttt{VisifyRouterImpl}, который инкапсулирует логику взаимодействия с \texttt{Cicerone Router}, предоставляя единый интерфейс для управления навигацией внутри приложения. Такой подход не только упрощает работу с \texttt{Cicerone}, но и позволяет разработчикам переопределять логику переходов для специфичных сценариев, не затрагивая базовую инфраструктуру. Для сопоставления \texttt{VisifyScreen} с соответствующими \texttt{Fragment} внутри отдельных модулей предлагается использовать \texttt{androidx.startup}, что позволяет автоматически инициализировать единый объект \texttt{ScreenMapping} на старте приложения. \texttt{UsableAppNavigator} расширяет стандартный \texttt{AppNavigator} и переопределяет метод \texttt{setupFragmentTransaction}, добавляя поддержку анимаций для экранов, реализующих \texttt{UsableFragmentScreen}. При навигации он проверяет, является ли переданный экран экземпляром \texttt{UsableFragmentScreen}, и если да, извлекает параметры анимации из связанного \texttt{VisifyScreen}, передавая их в \texttt{FragmentTransaction}.

\begin{lstlisting}[caption={Исходный код \texttt{VisifyRouterImpl}}]
class VisifyRouterImpl @Inject constructor(
    private val delegate: Router,
    private val factory: VisifyNavigatorTaskFactory,
) : VisifyRouter {

    private val screenStack = Stack<VisifyScreen>()

    override suspend fun navigateTo(screen: VisifyScreen) {
        navigateTo(screen, VisifyNavAnimation.SlideLeftRight)
    }

    override suspend fun navigateTo(screen: VisifyScreen, animation: VisifyNavAnimation) {
        val exit = screenStack.peekNullable()
        screenStack.add(screen)

        preNavigationCall(exit, screen)
        delegate.navigateTo(toCiceroneScreen(screen, animation))
    }

    override suspend fun newRootScreen(screen: VisifyScreen) {
        val exit = screenStack.popNullable()
        screenStack.clear()
        screenStack.add(screen)

        preNavigationCall(exit, screen)
        delegate.newRootScreen(toCiceroneScreen(screen, VisifyNavAnimation.ChangeAlpha))
    }

    override suspend fun replaceScreen(screen: VisifyScreen) {
        val replaced = screenStack.popNullable()
        screenStack.add(screen)

        preNavigationCall(replaced, screen)
        delegate.replaceScreen(toCiceroneScreen(screen, VisifyNavAnimation.ChangeAlpha))
    }

    override suspend fun backTo(screen: VisifyScreen?) {
        val exit = screenStack.popNullable()
        val next = when {
            screen != null -> screenStack.popWhile { it != screen }
            else -> screenStack.firstOrNull()?.apply {
                screenStack.clear()
                screenStack.add(this)
            }
        }

        preNavigationCall(exit, next)
        delegate.backTo(screen?.let { toCiceroneScreen(it) })
    }

    override suspend fun backToLastNotAuth() {
        val exit = screenStack.popNullable()
        val lastNotAuthScreen = screenStack.popWhile { it is AuthVisifyScreen }

        preNavigationCall(exit, lastNotAuthScreen)
        delegate.backTo(lastNotAuthScreen?.let { toCiceroneScreen(it) })
    }

    override suspend fun newChain(vararg screens: VisifyScreen) {
        val exit = screenStack.peekNullable()
        val actual = screens.lastOrNull()

        screenStack.addAll(screens)

        preNavigationCall(exit, actual)
        delegate.newChain(
            *screens.map { toCiceroneScreen(it, VisifyNavAnimation.ChangeAlpha) }
                .toTypedArray()
        )
    }

    override suspend fun newRootChain(vararg screens: VisifyScreen) {
        val exit = screenStack.popNullable()
        val actual = screens.lastOrNull()

        screenStack.clear()
        screenStack.addAll(screens)

        preNavigationCall(exit, actual)
        delegate.newRootChain(
            *screens.map { toCiceroneScreen(it, VisifyNavAnimation.ChangeAlpha) }
                .toTypedArray()
        )
    }

    override suspend fun finishChain() {
        val exit = screenStack.popNullable()
        preNavigationCall(exit, null)
        delegate.finishChain()
    }

    override suspend fun exit() {
        val exit = screenStack.popNullable()
        val next = screenStack.peekNullable()
        preNavigationCall(exit, next)
        delegate.exit()
    }

    private suspend fun preNavigationCall(
        prev: VisifyScreen?,
        next: VisifyScreen?,
    ) {

        val tasks = factory.collect()
        tasks.forEach { it.block(prev, next) }
    }

    private fun toCiceroneScreen(visify: VisifyScreen, anim: VisifyNavAnimation): FragmentScreen {
        when (anim) {
            VisifyNavAnimation.SlideLeftRight -> {
                visify.animEnter = R.anim.enter_from_right
                visify.animOut = R.anim.exit_to_left
                visify.popAnimEnter = R.anim.enter_from_left
                visify.popAnimOut = R.anim.exit_to_right
            }

            VisifyNavAnimation.SlideBottomTop -> {
                visify.animEnter = R.anim.enter_from_bottom
                visify.animOut = R.anim.exit_to_top
                visify.popAnimEnter = R.anim.enter_from_top
                visify.popAnimOut = R.anim.exit_to_bottom
            }

            VisifyNavAnimation.ChangeAlpha -> {
                visify.animEnter = R.animator.fade_in
                visify.animOut = R.animator.fade_out
            }
        }
        return toCiceroneScreen(visify)
    }

    private fun toCiceroneScreen(visify: VisifyScreen): FragmentScreen {
        val handler = SCREEN_MAP[visify::class.java]
        handler ?: throw IllegalStateException("Can't find handler for screen $visify")
        val screen = UsableFragmentScreen(visify) {
            handler.invoke(visify).factory.invoke()
        }

        return screen
    }

    private inline fun <T> Stack<T>.popWhile(predicate: (T) -> Boolean): T? {
        var curr = peekNullable()
        while (curr != null && predicate(curr)) {
            curr = peekNullable()
            popNullable()
        }
        return curr
    }

    private fun <T> Stack<T>.peekNullable(): T? {
        if (isEmpty()) return null
        return peek()
    }

    private fun <T> Stack<T>.popNullable(): T? {
        if (isEmpty()) return null
        return pop()
    }
}
\end{lstlisting}

\begin{lstlisting}[caption={Исходный код \texttt{UsableAppNavigator}}]
class UsableAppNavigator(
    activity: FragmentActivity,
    containerId: Int
) : AppNavigator(activity, containerId) {
    override fun setupFragmentTransaction(
        screen: FragmentScreen,
        fragmentTransaction: FragmentTransaction,
        currentFragment: Fragment?,
        nextFragment: Fragment,
    ) {
        if (screen !is UsableFragmentScreen) return
        multiLet(
            screen.clientScreen.animEnter,
            screen.clientScreen.animOut,
            screen.clientScreen.popAnimEnter,
            screen.clientScreen.popAnimOut
        ) { enter, exit, popEnter, popOut ->
            fragmentTransaction.setCustomAnimations(enter, exit, popEnter, popOut)
        }
    }
}
\end{lstlisting}

\section{Интеграция и тестирование модульной системы}
TODO()

%% Chapter 5
\chapter{Оценка эффективности решения}
\section{Методика оценки разработанного решения}

Оценка эффективности разработанного решения будет проводиться на основе количественных метрик, позволяющих объективно измерить его влияние на архитектуру проекта и скорость работы команд. В качестве ключевых показателей выбраны три метрики: уровень покрытия \texttt{unit-тестами}, степень дублирования кода и динамика \texttt{velocity} продуктовых команд.

Первый аспект оценки — анализ покрытия кода \texttt{unit-тестами}. Будет произведено сравнение исходного состояния проекта и состояния после внедрения разработанного решения. Основное внимание уделяется количеству кода, который стал доступен для тестирования без необходимости создания сложных моков зависимостей \texttt{AndroidSDK}. Это позволит оценить, насколько лучше новый подход способствует изоляции бизнес-логики и снижению связности с платформенными зависимостями.

Вторым критерием выступает анализ дублирования кода. Для выявления схожих фрагментов используется метод сравнения файлов с помощью расстояния Левенштейна, а также анализ паттернов с помощью регулярных выражений. Основной целью является оценка уменьшения количества повторяющихся реализаций общих методологий, таких как управление \texttt{ViewModel}, работа с \texttt{FusedLocationProvider}, сохранение данных в 
\texttt{Preferences} и других инфраструктурных компонентов. Снижение уровня дублирования позволит говорить о лучшей модульности и переиспользуемости компонентов.

Третья метрика направлена на оценку влияния изменений на скорость работы продуктовых команд. Будет произведен сравнительный анализ \texttt{velocity} до и после интеграции модульного подхода, с учетом данных по завершенным задачам за спринты. Изменение этого показателя позволит судить о том, насколько разработанные инструменты упростили процесс добавления новых фич и уменьшили время, затрачиваемое на рутинные задачи.

Комплексный анализ этих метрик позволит не только количественно оценить результат внедренных решений, но и выявить возможные узкие места, требующие дальнейших улучшений.

\section{Анализ полученных результатов}

\subsection{Анализ метрики покрытия unit-тестами}
Для количественной оценки покрытия unit-тестами использовались инструменты анализа кода, такие как \texttt{Jacoco}. \texttt{Jacoco} как раз имеет интеграцию с системой сборки \texttt{Gradle}, позволяя анализировать подробные отчеты о том, какие части кода были покрыты тестами, а какие остались не протестированными. Данный механизм может работать как с unit-тестами, так и с интеграционными. В контексте нашей работы, \texttt{Jacoco} был использован для анализа покрытия unit-тестами как до внедрения разработанного решения, так и после. Данные, собранные с помощью \texttt{Jacoco} отображены в таблице \ref{jacoco}. Проанализировав данные, с учетом того, что интеграция была произведена в августе 2024 года, можно заметить прирост процента покрытия новых классов тестами, что свидетельствует о положительной динамике, а следовательно и о результативности предложенного решения.

\begin{table}[!h]
\caption{Данные с динамикой покрытия новых классов тестами}\label{jacoco}
\centering
\begin{tabularx}{\textwidth}{|*{18}{>{\centering\arraybackslash}X|}}\hline
Дата & Количество новых классов & Количество классов в проекте & Количество протестированных новых классов & Покрытие новых классов \\\hline
03.2024 & 99 & 7576 & 13 & 13.1\% \\\hline
04.2024 & 110 & 7786 & 17 & 15.4\% \\\hline
05.2024 & 97 & 7883 & 12 & 12.3\% \\\hline
06.2024 & 121 & 8004 & 21 & 17.3\% \\\hline
07.2024 & 87 & 8091 & 9 & 10.3\% \\\hline
08.2024 & 103 & 8194 & 11 & 10.6\% \\\hline
09.2024 & 108 & 8302 & 19 & 17.5\% \\\hline
10.2024 & 105 & 8407 & 31 & 29.5\% \\\hline
11.2024 & 93 & 8500 & 38 & 40.8\% \\\hline
12.2024 & 108 & 8608 & 45 & 41.6\% \\\hline
01.2025 & 117 & 8725 & 61 & 52.1\% \\\hline
02.2025 & 101 & 8826 & 58 & 57.4\% \\\hline
\end{tabularx}
\end{table}

\subsection{Анализ метрики дублирования кода}

Для анализа дублирования кода использовался метод сравнительного анализа файлов с помощью расстояния Левенштейна (или \texttt{edit distance}), а также паттерн-матчинга с использованием регулярных выражений. Это позволило выявить участки кода, которые имеют схожую структуру и функциональность, но могут быть реализованы несколько раз в разных местах проекта. Для оценки дублирования кода были рассмотрены несколько ключевых методологий, таких как управление ViewModel, взаимодействие с FusedLocationProvider, работа с Preferences и другими инфраструктурными компонентами, которые часто повторяются в проекте. Сравнение файлов было выполнено по их текстовому содержимому и структурным признакам. Использовался стандартный инструмент для анализа дублирования, который на основе алгоритма Левенштейна вычисляет количество изменений, необходимых для преобразования одного фрагмента кода в другой. Чем меньшее количество изменений требуется, тем более схожи два фрагмента. Также были использованы регулярные выражения для выявления типичных паттернов, таких как объявления переменных, блоки кода, управляющие конструкции, что позволяет точно отслеживать повторяющиеся фрагменты. Полученные данные отражены в таблице \ref{duplicate}. Из данных видно, что после начала интеграции подхода, направленного на уменьшение дублирования кода, процент повторяющихся фрагментов начинает сокращаться. Уже через полгода после начала интеграции наблюдается улучшение: процент дублирования уменьшился с 18.5\% до 12.3\%. Также стоит отметить, что среднее количество строк дублирующегося кода на файл снизилось, что подтверждает, что не только количество дублированных файлов, но и их объем сократился. В целом, можно сделать вывод, что интеграция модульного подхода и методов для снижения дублирования привела к значительному улучшению качества кода, что, в свою очередь, уменьшило количество потенциальных ошибок и повысило стабильность приложения.

\begin{table}[!h]
\caption{Данные о дублирующемся коде в проекте}\label{duplicate}
\centering
\begin{tabularx}{\textwidth}{|*{18}{>{\centering\arraybackslash}X|}}\hline
Период & Количество файлов с дублированием & Процент дублирования & Среднее количество строк дублирующегося кода на файл \\\hline
До интеграции & 102 & 18.5\% & 45 \\\hline
1 месяц после интеграции & 98 & 16.2\% & 42 \\\hline
3 месяца после интеграции & 90 & 14.1\% & 38 \\\hline
6 месяцев после интеграции & 80 & 12.3\% & 35 \\\hline
\end{tabularx}
\end{table}

\subsection{Анализ \texttt{velocity} продуктовых команд}
Одним из ключевых факторов оценки эффективности внедрения модульного подхода является изменение скорости разработки, измеряемое через метрику \texttt{velocity} продуктовых команд. Для этого использовались данные из системы управления проектами \texttt{Jira}, где для каждой задачи в спринте были указаны \texttt{story-points} — условные единицы измерения объема работы, которые оценивают сложность и объем задачи.
Основная цель анализа заключалась в том, чтобы оценить, насколько увеличилась скорость реализации бизнес-логики после внедрения модульных решений. Было произведено сравнение количество потраченных \texttt{story-points} на задачи, связанные с разработкой и интеграцией бизнес-логики до и после внедрения изменений в структуру проекта. Полученные данны отображены в таблице \ref{story-points}. На основе полученных данных можно сделать вывод,  что среднее количество \texttt{story-points}, выполненных за спринт, увеличилось с 55 до 65. Это свидетельствует о повышении скорости разработки после внедрения модульного подхода. Такой рост демонстрирует успешность модульного подхода, который помогает команде быстрее и эффективнее разрабатывать новые функциональности.

\begin{table}[!h]
\caption{Данные о скорости разработки продуктовыми командами}\label{story-points}
\centering
\begin{tabularx}{\textwidth}{|*{18}{>{\centering\arraybackslash}X|}}\hline
Период & Среднее количество story-points за спринт \\\hline
3 месяца до интеграции & 52 \\\hline
1 месяц до интеграции & 55 \\\hline
1 месяц после интеграции & 53 \\\hline
3 месяца после интеграции & 65 \\\hline
\end{tabularx}
\end{table}

\section{Выводы по эффективности и возможностям доработки}

TODO()

\startconclusionpage

В данном разделе размещается заключение.

\end{document}
