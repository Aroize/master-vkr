## Введение

Внедрение зависимостей (Dependency Injection, DI) является одним из наиболее эффективных подходов 
для управления зависимостями между компонентами в программных системах. В нашем проекте используется
библиотека **Hilt**, которая представляет собой расширение библиотеки **Dagger** и интегрируется с
платформой Android. Выбор Hilt для внедрения зависимостей обоснован его возможностями по упрощению работы с DI,
снижению объема шаблонного кода, улучшению читабельности и облегчению интеграции компонентов приложения.
Hilt упрощает внедрение зависимостей, обеспечивая гибкость, удобство и минимизацию ошибок при взаимодействии между модулями.

Hilt предоставляет стандартные способы управления жизненным циклом зависимостей и их внедрением
в различные компоненты приложения, такие как Activity, Fragment, ViewModel и другие.
Важным аспектом использования Hilt является его способность работать с различными областями видимости (scopes),
что помогает избегать проблем с управлением состоянием и памятью. Данный документ будет ориентирован на разработчиков
и поможет правильно внедрять зависимости с использованием Hilt в проекте.

---

## Основные принципы работы с Hilt

### 1. Управление жизненным циклом зависимостей

Одним из ключевых преимуществ Hilt является возможность легко управлять жизненным циклом зависимостей 
через аннотации скоупов. В проекте мы активно используем следующие скоупы:

- `@Singleton`: Для сервисов, которые должны существовать в рамках всего жизненного цикла приложения.
- `@ActivityRetainedScoped`: Для зависимостей, которые должны сохраняться между конфигурационными изменениями
(например, при изменении ориентации экрана).
- `@ViewModelScoped`: Для зависимостей, которые должны быть привязаны к жизни ViewModel.

Пример использования:

```kotlin
@Singleton
class NetworkService @Inject constructor(private val apiClient: ApiClient) {
    // Логика работы с сетью
}
```
Скоупы позволяют обеспечить управление временем жизни зависимостей, что критически важно для 
эффективного использования ресурсов, таких как сетевые соединения или базы данных.

###  2. Стандартные скоупы, используемые в проекте
В проекте мы использовали несколько скоупов, наиболее часто встречающихся в приложениях Android:

`@Singleton`: Для объектов, которые должны быть созданы один раз на весь срок жизни приложения.
`@ActivityScoped`: Для зависимостей, которые создаются и уничтожаются вместе с жизненным циклом Activity.
`@FragmentScoped`: Для зависимостей, привязанных к жизненному циклу Fragment.
`@ViewModelScoped`: Для зависимостей, которые сохраняются в ViewModel, управляя состоянием экрана.
Правильное использование скоупов помогает избежать утечек памяти и обеспечивает эффективное распределение зависимостей.

### 3. Использование аннотаций @Module и @InstallIn
Для объявления зависимостей используется аннотация `@Module`, которая сообщает Hilt, что данный класс 
является модулем, содержащим методы для предоставления зависимостей. Аннотация `@InstallIn` указывает 
компонент, в который этот модуль будет установлен.

Пример:
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {

    @Provides
    fun provideApiService(client: OkHttpClient): ApiService {
        return Retrofit.Builder()
            .baseUrl("https://api.example.com/")
            .client(client)
            .build()
            .create(ApiService::class.java)
    }
}
```
Как структурировать зависимости

#### Организация зависимостей между модулями
При проектировании модульной архитектуры важно придерживаться принципа изоляции и слабой связанности 
между модулями. Каждый модуль должен быть независим от других и не иметь неявных зависимостей. 
Это облегчает тестирование, поддержку и дальнейшее расширение проекта.

В идеале, зависимости внутри одного модуля должны быть минимальными. Каждый модуль должен содержать 
как можно меньше логики, чтобы быть легко заменяемым и тестируемым. Например, модуль, отвечающий за 
сетевое взаимодействие, должен быть полностью изолирован от других слоев приложения, и только через 
интерфейсы должен предоставлять свои функциональные возможности.

#### Рекомендации по внедрению зависимостей внутри одного модуля
Когда необходимо внедрить зависимости внутри одного модуля, следует использовать такие подходы, как:
* Интерфейсы и абстракции: Это помогает отделить реализацию от использования и повысить гибкость системы.
* Тестируемость: Использование абстракций и инъекций через конструкторы упрощает создание тестов.
#### Разделение интерфейсов (API) и реализаций (impl)
Для того чтобы обеспечить гибкость и масштабируемость проекта, важно разделять интерфейсы и их реализации.
Это позволяет легко изменять реализации без изменения клиентского кода и облегчает масштабирование.

### 4. Примеры кода

```kotlin
interface ApiService {
    suspend fun fetchData(): Response
}

class ApiServiceImpl @Inject constructor(
    private val retrofit: Retrofit
) : ApiService {
    override suspend fun fetchData(): Response {
        return retrofit.create(ApiService::class.java).fetchData()
    }
}
```
Внедрение зависимостей через конструктор
Hilt поддерживает инъекцию зависимостей через конструкторы классов, что позволяет избежать 
громоздкой инициализации объектов вручную.

Пример:
```kotlin
@HiltViewModel
class MyViewModel @Inject constructor(
    private val networkService: NetworkService
) : ViewModel() {
    // Логика ViewModel
}
```
Создание модуля с использованием `@Module` и `@InstallIn`
Чтобы предоставить зависимости в определенные компоненты приложения, необходимо использовать 
модули с аннотациями `@Module` и `@InstallIn.`

Пример:
```kotlin
@Module
@InstallIn(ActivityComponent::class)
object AuthModule {

    @Provides
    fun provideAuthService(): AuthService {
        return AuthServiceImpl()
    }
}
```

### 5. Стандартные ошибки и их решение
#### Ошибка циклических зависимостей

Циклические зависимости возникают, когда два или более компонента напрямую зависят друг от друга. 
Это может привести к исключениям или бесконечным циклам.

**Решение**: Чтобы избежать циклических зависимостей, можно использовать интерфейсы и обеспечить 
инъекцию зависимостей через фабрики или прокси.

#### Неправильное использование скоупов

Если скоупы не используются правильно, это может привести к утечкам памяти или неверному времени жизни зависимостей.

**Решение**: Важно тщательно проверять скоупы и удостовериться, что зависимости сохраняются только 
в пределах их жизненного цикла. Для временных объектов используйте более короткие скоупы, а для долгоживущих -- @Singleton.

#### Ошибки при инъекции зависимостей

Если зависимость не может быть инъектирована, это обычно связано с отсутствием соответствующего 
компонента или неправильным скоупом.

**Решение**: Проверить, что все необходимые зависимости правильно настроены и 
модули объявлены корректно.

### 6. Рекомендации по тестированию
#### Создание тестовых окружений с Hilt

Hilt позволяет легко создавать тестовые окружения, заменяя зависимости в тестах с 
помощью аннотаций типа @TestInstallIn.

Пример:

```kotlin
@TestInstallIn(
    components = [SingletonComponent::class],
    replaces = [NetworkModule::class]
)
@Module
object TestNetworkModule {

    @Provides
    fun provideApiService(): ApiService {
        return FakeApiService()
    }
}
```
#### Мокирование зависимостей
Для юнит-тестов можно мокировать зависимости с использованием Hilt, что позволяет создать 
изолированные тесты без необходимости развертывания полноценной инфраструктуры.
Пример:

```kotlin
@HiltAndroidTest
class MyViewModelTest {

    @Inject lateinit var myViewModel: MyViewModel

    @Before
    fun setUp() {
        hiltRule.inject()
    }

    @Test
    fun testViewModelBehavior() {
        // Тестирование поведения ViewModel
    }
}
```

